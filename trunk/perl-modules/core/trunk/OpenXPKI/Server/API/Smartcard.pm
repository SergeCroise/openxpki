## OpenXPKI::Server::API::Smartcard.pm 
##
## Written 2010 by Martin Bartosch for the OpenXPKI project
## Copyright (C) 2005-2010 by The OpenXPKI Project

package OpenXPKI::Server::API::Smartcard;

use strict;
use warnings;
use utf8;
use English;

use OpenXPKI::Debug;
use OpenXPKI::Exception;
use OpenXPKI::Server::Context qw( CTX );
use OpenXPKI::Crypto::X509;
use DateTime;
use OpenXPKI::DateTime;
use OpenXPKI::i18n;

use Net::LDAP;
use Class::Std;
use MIME::Base64;
use Data::Dumper;
use Digest::SHA1 qw( sha1_hex );

sub START {
    # somebody tried to instantiate us, but we are just an
    # utility class with static methods
    OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SUBCLASSES_CAN_NOT_BE_INSTANTIATED',
    );
}

# named parameters:
# CERTFORMAT => DER|PEM|IDENTIFIER|BASE64 (allows degraded formats, 
#   e. g. without newlines)
# CERTS => arrayref, entries contain raw cert data
sub sc_parse_certificates {
    ##! 1: 'init'
    my $self = shift;
    my $arg_ref = shift;

    my $cfg_id = $arg_ref->{CONFIG_ID};
    
    if ($arg_ref->{CERTFORMAT} !~ m{ \A (?:DER|PEM|BASE64|IDENTIFIER) \z }xms) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_PARSE_CERTIFICATES_INVALID_CERT_FORMAT',
	    params  => {
		CERTFORMAT => $arg_ref->{CERTFORMAT},
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    my $certs = $arg_ref->{CERTS};

    my @result;

    foreach my $entry (@{$certs}) {
	my $data = $self->sc_analyze_certificate(
	    {
		CONFIG_ID  => $cfg_id,
		DATA       => $entry,
		CERTFORMAT => $arg_ref->{CERTFORMAT},
	    });

	##! 16: 'parsed certificate: ' . Dumper $data

	push @result, $data;
    }
    ##! 1: 'parsed certs: ' . Dumper \@result;
    return \@result;
}


# named parameters:
# SCMARTCARDID => scalar, token id read from token. format: TYPE_SERIAL
# 
# CERTFORMAT => see sc_parse_certificates
# CERTS => see sc_parse_certificates
# USERID => scalar, authenticated user (optional, if present may be 
#           different from sc holder)
# WORKFLOW_TYPES => arrayref, existing workflow types to search (optional)
sub sc_analyze_smartcard {
    my $self = shift;
    my $arg_ref = shift;

    my $tokenid  = $arg_ref->{SMARTCARDID};
    my $userid   = $arg_ref->{USERID};
    my $wf_types = $arg_ref->{WORKFLOW_TYPES};
    my $cfg_id   = $arg_ref->{CONFIG_ID};
    ##! 16: 'cfg_id: ' . $cfg_id

    ##! 16: 'sc_analyze_smartcard() wf_types = $wf_types (' . Dumper($wf_types) . ')'

    if (defined $wf_types && (ref $wf_types ne 'ARRAY')) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_INVALID_WORKFLOW_TYPES_UNEXPECTED_DATA_TYPE',
	    params  => {
		DATA_TYPE => ref $wf_types,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    my $thisrealm = CTX('session')->get_pki_realm();

    my $smartcard_holder_login_id;

    # get policy settings from configuration
    my $policy = $self->_get_policy();
    

    my $result = {
        WF_TYPES => $wf_types,
	OVERALL_STATUS => 'green',
	SMARTCARD => {
	    serialnumber => '',
	    status => 'unknown',
	    assigned_to => {},
	    keyalg => 'RSA',
	    keysize => 2048,
	    default_puk => undef,
	},
	CERT_TYPE => {
#	    'nonescrow' => {
#		usable_cert_exists => 0,
#		token_contains_expected_cert => 0,
#	    },
	  # 2010-09-17 MB FIXME: the following section disables escrow 
	  # certificate generation, cleanup and remove!
	    'escrow' => {
		usable_cert_exists => 1,
		token_contains_expected_cert => 1,
	    },
	    # certificates known to our PKI system but not expected on card
	    # (should be purged)
	    #'OTHER' => {
	    #
	    #},
	    # 3rd party certificates, keep on card
	    #'FOREIGN' => {
	    #    
	    #},
	},
	WORKFLOWS => undef,
	PROCESS_FLAGS => {
	    # user is allowed to start a personalization workflow (complex
	    # decision based on smartcard status, puk availability etc)
	    allow_personalization => 1,
	    # smartcard PIN is required for following operations (either
	    # the user's pin or an autogenerated random pin)
	    will_need_pin => 0,
	    # policy setting: if set to 0 the user may select his own pin,
	    # otherwise the pin will be selected by the server
	    will_need_random_pin => 1,
	    # allow user to enter existing pin (otherwise 
	    # autogenerate random pin -> pin unblock needed after 
	    # completion)
	    allow_user_pin => 0,
	    # policy setting: if set 0 no approval is required for user cert
	    # issuance
	    need_wf_approval => 0,
	    # policy setting: if true the token must be completely purged
	    # before an unblock operation may happen
	    purge_token_before_unblock => 0,
	    # smartcard cleanup is necessary
	    have_cert_to_delete => 0,
	    # directory cleanup is necessary
	    have_cert_to_unpublish => 0,
	    # smartcard puk can be modified
	    puk_is_writable => 1,
	    # smartcard puk is available in datapool
	    puk_found_in_datapool => 0,
	},
    };


    ###########################################################################
    my $ldap = Net::LDAP->new(
	$policy->{directory}->{ldap}->{uri},
	#port => $ldap_settings->{ldap_port},
	onerror => undef,
	);

    if (! defined $ldap) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_CONNECTION_FAILED',
	    params  => {
		LDAP_SERVER => $policy->{directory}->{ldap}->{uri},
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    my $mesg = $ldap->bind(
	$policy->{directory}->{ldap}->{bind_dn},
	password => $policy->{directory}->{ldap}->{pass},
	);

    if ($mesg->is_error()) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_BIND_FAILED',
	    params  => {
		ERROR => $mesg->error(),
		ERROR_DESC => $mesg->error_desc(),
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    # determine smartcard status
    $mesg = $ldap->search(
	base => $policy->{directory}->{smartcard}->{basedn},
	filter => "scbserialnumber=$tokenid",
	attrs => [ 'scbserialnumber', 'scbstatus' ],
	);

    if ($mesg->is_error()) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_TOKENID_FAILED',
	    params  => {
		ERROR => $mesg->error(),
		ERROR_DESC => $mesg->error_desc(),
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    my @sc_entries = $mesg->entries();
    if (scalar @sc_entries > 0) {
	# smartcard is known to the system, allocate output structure

	##! 16: "smartcard with id $tokenid found in ldap"
	
	# check result for uniqueness (multiple results could happen if
	# a wildcard was specified)
	if (scalar @sc_entries > 1) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_TOKENID_NOT_UNIQUE',
		params  => {
		    TOKENID => $tokenid,
		    COUNT => scalar @sc_entries,
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);
	}

	# unique token found, propagate ldap data to return structure
	$result->{SMARTCARD}->{status} =
	    $sc_entries[0]->get_value('scbstatus');

	# sanity check, only allow defined smartcard status
	if ($result->{SMARTCARD}->{status} !~ m{ \A (?:initial|activated|deactivated) \z }xms) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_INVALID_SMARTCARD_STATUS',
		params  => {
		    TOKENID => $tokenid,
		    STATUS  => $result->{SMARTCARD}->{status},
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);
	}

	$result->{SMARTCARD}->{serialnumber} =
	    $sc_entries[0]->get_value('scbserialnumber');

	my $smartcard_dn = $sc_entries[0]->dn();
	##! 16: 'associated smartcard dn: ' . $smartcard_dn

	# sanity check: token id must be identical to the one passed
	# in the api call
	if ($tokenid 
	    ne $result->{SMARTCARD}->{serialnumber}) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_TOKENID_MISMATCH',
		params  => {
		    TOKENID_FROM_API => $tokenid,
		    TOKENID_FROM_LDAP => $result->{SMARTCARD}->{serialnumber},
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);

	}

	# get assigned person
	##! 16: "searching for seealso=$smartcard_dn in $policy->{directory}->{person}->{basedn}"
	$mesg = $ldap->search(
	    base => $policy->{directory}->{person}->{basedn},
	    scope => 'sub',
	    filter => "seealso=$smartcard_dn",
	    attrs => $policy->{directory}->{person}->{attributes},
	    );
	
	if ($mesg->is_error()) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_PERSON_FAILED',
		params  => {
		    ERROR => $mesg->error(),
		    ERROR_DESC => $mesg->error_desc(),
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
	    );
	}

	my @person_entries = $mesg->entries();
	##! 16: 'person search: ' . Dumper \@person_entries

	if (scalar(@person_entries) > 0) {
	    # at least one associated user found

	    if (scalar(@person_entries) > 1) {
		# smartcard is held by too many users
		OpenXPKI::Exception->throw(
		    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_TOO_MANY_SMARTCARD_OWNERS',
		    params  => {
			ASSIGNED_TO => join('; ', map { $_->dn() } 
					    @person_entries),
		    },
		    log => {
			logger => CTX('log'),
			priority => 'error',
			facility => [ 'system', ],
		    },
		    );
	    }

	    ##! 16: 'person entry: ' . Dumper $person_entries[0]
	    ##! 16: 'person dn: ' . $person_entries[0]->dn()
	    
	    $result->{SMARTCARD}->{assigned_to}->{dn} = 
		$person_entries[0]->dn();
	    

	    foreach my $attr ($person_entries[0]->attributes()) {
		my %flags = ();
		if ($attr eq $policy->{directory}->{person}->{loginid_attribute}) {
		    $flags{asref} = 1;
		}
		$result->{SMARTCARD}->{assigned_to}->{$attr} = 
		    $person_entries[0]->get_value($attr, %flags);
	    }

	    ##! 16: 'smartcard holder details from ldap: ' . Dumper $result->{SMARTCARD}->{assigned_to}

	    $smartcard_holder_login_id = 
		$person_entries[0]->get_value(
		    $policy->{directory}->{person}->{userid_attribute}
		);
	    $result->{SMARTCARD}->{assigned_to}->{workflow_creator} = $smartcard_holder_login_id;

	    if (defined $policy->{directory}->{person}->{max_smartcards_per_user}) {
		##! 16: 'checking for max number of smartcards per user'
		
		foreach my $person (@person_entries) {
		    my $person_dn = $person->dn();
		    
		    $mesg = $ldap->search(
			base => $policy->{directory}->{person}->{basedn},
			filter => $person_dn,
			attrs => [ 'seealso', ],
			);
		    if (! $mesg->is_error()) {
			my @smartcard_entries = $mesg->entries();
			if (scalar @smartcard_entries 
			    > $policy->{directory}->{person}->{max_smartcards_per_user}) {

			    OpenXPKI::Exception->throw(
				message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_TOO_MANY_SMARTCARDS',
				params  => {
				    USER => $person_dn,
				    SMARTCARD_COUNT => scalar @smartcard_entries,
				    SMARTCARDS => join(';', map { $_->get_value('seealso') } @smartcard_entries),
				},
				log => {
				    logger => CTX('log'),
				    priority => 'error',
				    facility => [ 'system', ],
				},
				);
			}
		    }
		}
	    }
	}
    }


    ###########################################################################
    # check membership of logged in user (if specified) in configured groups
    if (defined $userid) {
	# first get the DN of the logged in user

	my $attribute = $policy->{directory}->{person}->{userid_attribute};

	$mesg = $ldap->search(
	    base => $policy->{directory}->{person}->{basedn},
	    scope => 'one',
	    filter => "$attribute=$userid",
	    attrs => [ 'dn' ],
	    );

	if ($mesg->is_error()) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_USERID_FAILED',
		params  => {
		    ERROR => $mesg->error(),
		    ERROR_DESC => $mesg->error_desc(),
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);
	}
	
	my $dn;
	my @entries = $mesg->entries();
	if (scalar(@entries) > 0) {
	    if (scalar(@entries) > 1) {
		OpenXPKI::Exception->throw(
		    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_LDAP_SEARCH_AMBIGUOUS_USER',
		    params  => {
			$attribute => $userid,
			COUNT => scalar @entries,
		    },
		    log => {
			logger => CTX('log'),
			priority => 'error',
			facility => [ 'system', ],
		    },
		    );
	    }
	    $dn = $entries[0]->dn();
	}

	##! 16: "userid $userid maps to dn $dn"

	foreach my $group_alias (keys %{$policy->{directory}->{groups}}) {
	    my $ldap_group = $policy->{directory}->{groups}->{$group_alias};

	    my $process_flag = 'is_' . $group_alias;
	    $result->{PROCESS_FLAGS}->{$process_flag} = 0;

	    if (defined $dn) {
		# determine smartcard status
		##! 16: 'checking membership for ldap group ' . $ldap_group
		$mesg = $ldap->search(
		    base => $ldap_group,
		    scope => 'base',
		    filter => "uniqueMember=$dn",
		    attrs => [ 'dn' ],
		    );

		if ($mesg->count() == 1) {
		    $result->{PROCESS_FLAGS}->{$process_flag} = 1;
		}
	    }
	}
    }
    
    
    ###########################################################################
    # search workflows
    if ((defined $wf_types) &&
	(defined $smartcard_holder_login_id)) {
	# get workflow information (existing workflows for user)
	foreach my $wf_type (@{$wf_types}) {
	    $result->{WORKFLOWS}->{$wf_type} =
		CTX('api')->search_workflow_instances(
		    {
			TYPE => $wf_type,
			CONTEXT => [
			    {
				KEY => 'creator',
				VALUE => $smartcard_holder_login_id,
			    },
			    ],
		    });
	}
    }

    ###########################################################################
    # check if puk can be found in datapool
    my $puk_found = CTX('dbi_backend')->first(
	TABLE => 'DATAPOOL',
	DYNAMIC => {
	    PKI_REALM => $thisrealm,
	    NAMESPACE => 'smartcard.puk',
	    DATAPOOL_KEY => $tokenid,
	}
	);

    if (defined $puk_found) {
	$result->{PROCESS_FLAGS}->{puk_found_in_datapool} = 1;
    }

    ###########################################################################
    # smartcard type specific settings
    if ($tokenid =~ m{ \A (?:rsa[23]_) }xms) {
	$result->{PROCESS_FLAGS}->{puk_is_writable} = 0;
	# RSA tokens must be wiped before they can be unblocked
	$result->{PROCESS_FLAGS}->{purge_token_before_unblock} = 1;
	$result->{SMARTCARD}->{keysize} = 1024;
	$result->{SMARTCARD}->{default_puk} = undef;
    } elsif ($tokenid =~ m{ \A (?:gem2_) }xms) {
	$result->{PROCESS_FLAGS}->{puk_is_writable} = 1;
	$result->{SMARTCARD}->{keysize} = 2048;
	$result->{SMARTCARD}->{default_puk} = '0' x 48;
    } else {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_UNSUPPORTED_SMARTCARD_TYPE',
	    params  => {
		TOKEN_ID => $tokenid,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }


    ###########################################################################
    # analyze contents of the card
    $result->{PARSED_CERTS} = $self->sc_parse_certificates($arg_ref);

    ###########################################################################
    # get existing certificates

    ##! 16: 'get existing certificates for user ' . $smartcard_holder_login_id
    if ($policy->{directory}->{person}->{userid_attribute} ne 'mail') {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_UNSUPPORTED_USERID_ATTRIBUTE',
	    params  => {
		USERID_ATTRIBUTE => $policy->{directory}->{person}->{userid_attribute},
	    },
	    log => {
		logger => CTX('log'),
		priority => 'fatal',
		facility => [ 'system', ],
	    },
	    );
    }


    my $user_certs = {
	by_identifyer => {},
	by_type => {},
	by_profile => {},
	xref => {
	    expected_certs => {
		all => {
		    list => [],
		    # preallocate identifer hash (needed later)
		    identifier => {},
		}
	    },
	},
    };
    foreach my $type (keys %{$policy->{certs}->{type}}) {
	next if ($type =~ m{ \A (?:UNEXPECTED|FOREIGN) \z }xms);
	$user_certs->{by_type}->{$type} = [];

	##! 16: 'certificates with type: ' . $type
	foreach my $profile (@{$policy->{certs}->{type}->{$type}->{allowed_profiles}}) {
	    $user_certs->{by_profile}->{$profile} = [];
	    ##! 16: 'certificate profile: ' . $profile

	    my $db_results = CTX('dbi_backend')->select(
		TABLE => [
		    'CERTIFICATE',
		    'CSR',
		],
		COLUMNS => [
		    'CSR.PROFILE',
		    'CERTIFICATE.SUBJECT',
		    'CERTIFICATE.IDENTIFIER',
		    'CERTIFICATE.ROLE',
		    'CERTIFICATE.STATUS',
		    'CERTIFICATE.DATA',
		    'CERTIFICATE.NOTBEFORE',
		    'CERTIFICATE.NOTAFTER',
		],
		DYNAMIC => {
		    'CSR.PROFILE' => $profile,
		    'CERTIFICATE.PKI_REALM' => $thisrealm,
		    'CERTIFICATE.EMAIL' => $smartcard_holder_login_id,
		},
		JOIN => [
		    [
		     'CSR_SERIAL',
		     'CSR_SERIAL',
		    ],
		],
		);
	    
	    # entry was found in the database
	    foreach my $entry (@{$db_results}) {
		my $db_hash = {};
# 		if (0) {
# 		    ##! 16: 'parsing certificate'
# 		    my $x509 = OpenXPKI::Crypto::X509->new(
# 			DATA => $db_results->{'CERTIFICATE.DATA'},
# 			TOKEN => $default_token,
# 			);
		    
# 		    $db_hash = { 
# 			$x509->to_db_hash(),
# 		    };
# 		}
		
		# merge database query results with parsed cert
		##! 16: 'merging certificate information from database'
		my $identifier = $entry->{'CERTIFICATE.IDENTIFIER'};
		$db_hash = {
		    %{$db_hash},
		    IDENTIFIER        => $identifier,
		    PROFILE           => $entry->{'CSR.PROFILE'},
		    ROLE              => $entry->{'CERTIFICATE.ROLE'},
		    SUBECT            => $entry->{'CERTIFICATE.SUBJECT'},
		    STATUS            => $entry->{'CERTIFICATE.STATUS'},
		    NOTBEFORE         => $entry->{'CERTIFICATE.NOTBEFORE'},
		    NOTAFTER          => $entry->{'CERTIFICATE.NOTAFTER'},
		};

		$db_hash = $self->__check_db_hash_against_policy($db_hash);
		
		##! 16: 'certificate details: ' . Dumper $db_hash

		# save full certificate details
		$user_certs->{by_identifier}->{$identifier} = $db_hash;
		
		# xrefs
		push @{$user_certs->{by_type}->{$type}}, 
		    $user_certs->{by_identifier}->{$identifier};
		push @{$user_certs->{by_profile}->{$profile}}, 
		    $user_certs->{by_identifier}->{$identifier};
	    }
	}
    }
    ##! 16: 'certificates already existing for user: ' . Dumper $user_certs

    ###########################################################################
    # process policy requirements for all user certificates

    foreach my $type (keys %{$policy->{certs}->{type}}) {
	next if ($type =~ m{ \A (?:UNEXPECTED|FOREIGN) \z }xms);

	$result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 0;
	$result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;
	
	my @expected_certs;
	my $max_certs = $policy->{certs}->{type}->{$type}->{limits}->{max_count};
	my $min_certs = $policy->{certs}->{type}->{$type}->{limits}->{min_count};
	my $cutoff_date;
	if (defined $policy->{certs}->{type}->{$type}->{limits}->{max_age}) {
	    $cutoff_date = OpenXPKI::DateTime::get_validity(
		{
		    REFERENCEDATE => DateTime->now(),
		    VALIDITY => $policy->{certs}->{type}->{$type}->{limits}->{max_age},
		    VALIDITYFORMAT => 'relativedate',
		});
	}

	# sort certificates by notbefore date (descending)
	@{$user_certs->{by_type}->{$type}} 
	    = sort { $b->{NOTBEFORE} <=> $a->{NOTBEFORE} } 
	        @{$user_certs->{by_type}->{$type}};
	
	
      CERT_TO_RETAIN:
	foreach my $entry (@{$user_certs->{by_type}->{$type}}) {
	    if (defined $max_certs && 
		(scalar @expected_certs >= $max_certs)) {
		##! 16: 'max number of certificates to retain reached: ' . $max_certs
		last CERT_TO_RETAIN;
	    }
	    
	    if (defined $cutoff_date) {
		##! 16: 'checking for maximum age: ' . Dumper $cutoff_date
		my $notbefore = DateTime->from_epoch( epoch => $entry->{NOTBEFORE} );
		if (DateTime->compare($notbefore, $cutoff_date) > 0) {
		    push @expected_certs, $entry->{IDENTIFIER};
		}
	    } else {
		push @expected_certs, $entry->{IDENTIFIER};
	    }
	}
	
	# propagate flag if at least one escrow certificate exists
	if (scalar @expected_certs > 0) {
	    $result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 1;
	    ##! 16: 'at least one certificate exists for type: ' . $type

	    # if the latest certficate has been revoked or is valid
	    # for less than the configured threshold, we propagate
	    # that we have no usable certificate
	    my $cert_id = $expected_certs[0];
	    my $cert = $user_certs->{by_identifier}->{$cert_id};
	    
	    if ($cert->{VALIDITY_PROPERTIES}->{allow_renewal}
		|| $cert->{VALIDITY_PROPERTIES}->{force_renewal}
		|| (!$cert->{VALIDITY_PROPERTIES}->{within_validity_period})
		|| (!$cert->{VALIDITY_PROPERTIES}->{not_revoked})) {
		##! 16: 'certificate does not qualify because of its validity properties: ' . Dumper $cert->{VALIDITY_PROPERTIES}
		$result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 0;
	    }

	    # if the latest certificate's private key is not in the database
	    # this does not qualify as a 'usable' certificate (only for
	    # certs which should be escrowed)
	    if ($policy->{certs}->{type}->{$type}->{escrow_key}
		&& ! $cert->{PRIVATE_KEY_AVAILABLE}) {
		##! 16: 'certificate does not qualify because it is supposed to be an escrowed cert and no private key is available'
		$result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 0;
	    }
	}
    
	
	# index by type
	$user_certs->{xref}->{expected_certs}->{type}->{$type}->{list} = \@expected_certs;
	%{$user_certs->{xref}->{expected_certs}->{type}->{$type}->{identifier}} = 
	    map { $_ => 1 } @expected_certs;

	# complete list
	push @{$user_certs->{xref}->{expected_certs}->{all}->{list}},
	    @expected_certs;

	# by identifier
	map { 
	    $user_certs->{xref}->{expected_certs}->{all}->{identifier}->{$_} = 1;
	} @expected_certs;
	
    }
    ##! 16: 'certificates sorted, by type: ' . Dumper $user_certs->{by_type}
    
    ##! 16: 'xref: ' . Dumper $user_certs->{xref}
    ###########################################################################
    # analyze certificates on card
    $result->{TASKS}->{SMARTCARD}->{INSTALL} = [];
    $result->{TASKS}->{SMARTCARD}->{PURGE} = [];
    $result->{TASKS}->{DIRECTORY}->{UNPUBLISH} = [];

    my $index = 0;
    
    my %to_restore = %{$user_certs->{xref}->{expected_certs}->{all}->{identifier}};
    ##! 16: 'to_restore: ' . Dumper \%to_restore

    # create a checklist of certs which are expected on the token
    my %missing_certs_on_token_by_type =
	%{$user_certs->{xref}->{expected_certs}->{type}};
    ##! 16: 'missing certs: ' . Dumper \%missing_certs_on_token_by_type

    my %certs_on_token_by_type;
    my %preferred_cert_available_by_type;

    foreach my $entry (@{$result->{PARSED_CERTS}}) {
	my $identifier = $entry->{IDENTIFIER};
	my $cert = $user_certs->{by_identifier}->{$identifier};
	my $cert_type = $cert->{CERTIFICATE_TYPE} || 'FOREIGN';
	my $cert_visual_status = $cert->{VISUAL_STATUS};
	my $is_preferred_profile = $cert->{PREFERRED_PROFILE};

	##! 16: 'identifier: ' . $identifier
	##! 16: 'type: ' . $cert_type
	##! 16: 'is preferred: ' . $is_preferred_profile
	$preferred_cert_available_by_type{$cert_type} ||= $is_preferred_profile;

	push @{$certs_on_token_by_type{$cert_type}}, $identifier;
	
	# escalate overall visual status
	if (defined $cert_visual_status) {
	    # do not consider certficates which are escrowed (used for
	    # encyption)
	    if (! $policy->{certs}->{type}->{$cert_type}->{escrow_key}) {
		$result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		    $result->{OVERALL_STATUS},
		    $cert_visual_status,
		    );
	    }
	}

	# remove cert from the list of expected certs
	delete $missing_certs_on_token_by_type{$cert_type}->{identifier}->{$identifier};
	
	# certificate possibly already exists on card, we don't have 
	# to recover it
	delete $to_restore{$identifier};

	# purge certificates already scheduled for deletion
	if ($entry->{PROCESS_FLAGS}->{PURGE}) {
	    $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	    $result->{PROCESS_FLAGS}->{have_cert_to_delete} = 1;
	    
	    push @{ $result->{TASKS}->{SMARTCARD}->{PURGE} },
	    {
		INDEX      => $index,
		IDENTIFIER => $entry->{IDENTIFIER},
		SUBJECT    => $entry->{SUBJECT},
		MODULUS_HASH => $entry->{MODULUS_HASH},
	    };
	}
    }
    ##! 16: 'missing certs: ' . Dumper \%missing_certs_on_token_by_type
    ##! 16: 'certs on token by type: ' . Dumper \%certs_on_token_by_type
    ##! 16: 'preferred profile found by type: ' . Dumper \%preferred_cert_available_by_type

    # identify certs to restore
    ##! 16: 'to_restore: ' . Dumper \%to_restore
  CERT_TO_RESTORE:
    foreach my $identifier (@{$user_certs->{xref}->{expected_certs}->{all}->{list}}) {
	##! 16: 'identifier: ' . $identifier
	my $cert = $user_certs->{by_identifier}->{$identifier};
	my $cert_type = $cert->{CERTIFICATE_TYPE};
	
	# only propagate escrow certificates for recovery
	if (defined $to_restore{$identifier}) {
	    ##! 16: 'flagged for recovery'

	    if ($policy->{certs}->{type}->{$cert_type}->{escrow_key}) {
		##! 16: 'is escrow cert, queue for recovery'

		if ($policy->{certs}->{type}->{$cert_type}->{ignore_certificates_with_missing_private_key}) {
		    ##! 16: 'checking if private key is available for cert identifier ' . $identifier
		    
		    if (! $cert->{PRIVATE_KEY_AVAILABLE}) {
			##! 16: 'private key not in datapool for cert identifier ' . $identifier
			next CERT_TO_RESTORE;
		    }
		}
		push @{$result->{TASKS}->{SMARTCARD}->{INSTALL}}, $identifier;
		$result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	    }
	}
    }

    # check for certificates missing on token
  CERT_TYPE:
    foreach my $type (keys (%missing_certs_on_token_by_type)) {
	next CERT_TYPE if ($type =~ m{ \A (?:FOREIGN|UNEXPECTED) }xms);
	my $min_count = $policy->{certs}->{type}->{$type}->{limits}->{min_count} || 0;
	##! 16: 'check if expected certificates are present for type ' . $type
	$result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 1;

	my $cert_count = 0;
	if (exists $certs_on_token_by_type{$type}) {
	    $cert_count = scalar @{$certs_on_token_by_type{$type}};
	}

	# check for minimum number of certs
	if ($cert_count < $min_count) {
	    ##! 16: "too few certs on token for type $type (found $cert_count, expected $min_count)"
	    $result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;
	    
	    $result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		$result->{OVERALL_STATUS},
		'red',
		);
	    $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	}

	if (scalar keys %{$missing_certs_on_token_by_type{$type}->{identifier}} > 0) {
	    ##! 16: 'certs missing on token: ' . Dumper $missing_certs_on_token_by_type{$type}->{identifier}
	    $result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;

	    $result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		$result->{OVERALL_STATUS},
		'red',
		);
	    $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	}
    }

    # check if preferred profile is available on token and possibly tell
    # workflow to upgrade certificate
    foreach my $type (keys %preferred_cert_available_by_type) {
	next if ($type eq 'FOREIGN');

	if ($policy->{certs}->{type}->{$type}->{promote_to_preferred_profile}) {
	    if (! $preferred_cert_available_by_type{$type}) {
		$result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;
		$result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		    $result->{OVERALL_STATUS},
		    'red',
		    );
		$result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	    }
	}
    }

    # an overall status that is not green indicates that we probably need the
    # pin
    if ($result->{OVERALL_STATUS} ne 'green') {
	$result->{PROCESS_FLAGS}->{will_need_pin} = 1;
    }

    ##! 16: 'analysis result: ' . Dumper $result
    return $result;
}

# compute new overall visual status based on input
# returns the "maximum" of the passed input values
# input: array of string, allowed values must be one of 'green', 'amber', 'red'
# output: "maximum" of the passed values
sub _aggregate_visual_status {
    my $self = shift;
    my @args = @_;
    my %escalation_level_of = (
	'green' => 0,
	'amber' => 1,
	'red' => 2,
	);
    my %color_of = map { $escalation_level_of{$_} => $_ } 
        keys %escalation_level_of;

    my $overall_level = 0;
    foreach my $status (@args) {
	if (! exists $escalation_level_of{$status}) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_AGGREGATE_VISUAL_STATUS_INVALID_STATUS_CODE',
		params  => {
		    VISUAL_STATUS => $status,
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);
	}
	if ($escalation_level_of{$status} > $overall_level) {
	    $overall_level = $escalation_level_of{$status};
	}
    }
    
    return $color_of{$overall_level};
}

sub _get_policy {
    my $self = shift;
    my $arg_ref = shift;

    our $policy =
    {
	directory => {
	    ldap => {
		uri => 'ldaps://localhost:389',
		bind_dn => 'cn=admin,dc=example,dc=com',
		pass => 'changeme',
	    },
	    person => {
		basedn => 'ou=persons,dc=example,dc=com',
		userid_attribute => 'mail',
		loginid_attribute => 'ntloginid',
		max_smartcards_per_user => 1,
		attributes =>  [ qw( CN givenName initials sn mail ) ],
	    },
	    smartcard => {
		basedn => 'ou=smartcards,dc=example,dc=com',
	    },
	    groups => {
		badge_officer => 'cn=Badge Officer,ou=groups,dc=example,dc=com',
	    },
	},
	certs => {
	    type => {
		'nonescrow' => {
                    # usages are literally reported back to caller
		    usage => [ 'AUTHENTICATION', 'SIGNATURE' ],
		    # list allowed profiles, with descending priority (first
		    # profile preferred) 
		    allowed_profiles => 
			[
			 'I18N_OPENXPKI_PROFILE_USER_AUTHENTICATION_NOMAIL',
			 'I18N_OPENXPKI_PROFILE_USER_AUTHENTICATION_MAIL',
			],
		    # if promote_to_preferred_profile is requested, analysis
		    # will schedule a certificate for re-issuance with the
		    # preferred profile from allowed_profiles if an older
		    # profile is found.
		    promote_to_preferred_profile => 1,
		    # if set to true the api function will check if a private
		    # key exists in the database when building a list of
		    # expected certificates. certificates with a missing
		    # private key will not be scheduled for recovery.
		    # obviously only applicable to escrowed certificates.
		    ignore_certificates_with_missing_private_key => 0,
		    # limits for this type of certificates on token 
		    # min_count: integer, min required number of certs
		    # max_count: integer
		    # max_age: string, '-YY', number of years to keep old certs
		    limits => {
			min_count => 1,
			max_count => 1,
		    },
		    # allow renewal of this type of certificates before
		    # expiration (will result in "amber" condition)
		    allow_renewal => '-0003', # 00 years, 03 months
		    # force renewal before expiration (will result in
		    # "red" condition)
		    force_renewal => '-000014', # 14 days
		    # if key_escrow is set to 0 the key is generated on the
		    # token. certificate is not recoverable.
		    # if key_escrow is set to 1 the key is generated in the
		    # PKI system. cert and key can be recovered by the user
		    # (in case of lost or damaged token) or by an escrow
		    # officer.
		    # expired certificates with escrow_key = 1 are never 
		    # purged from the smartcard until limits/max_age or
		    # limits/max_count is exceeded
		    escrow_key => 0,
		    # if publish is set to 1 a newly issued certificate
		    # of this type is published to the configured directory
		    publish => 0,
		    # if purge_invalid is set, only keep valid certificates
		    # on smartcard
		    purge_invalid => 1,
		},
		'escrow' => {
		    usage => [ 'ENCRYPTION' ],
		    allowed_profiles => 
			[
			 'I18N_OPENXPKI_PROFILE_USER_ENCRYPTION',
			 'I18N_OPENXPKI_PROFILE_USER_FSE',
			],
		    promote_to_preferred_profile => 1,
		    ignore_certificates_with_missing_private_key => 1,
		    limits => {
			min_count => 1,
			max_count => 8,
			max_age => '-10',  # years
		    },
		    allow_renewal => '-0003',
		    force_renewal => undef,
		    escrow_key => 1,
		    publish => 1,
		    purge_invalid => 0,
	        },
		# certificates known to our PKI but not explicitly listed above
		'UNEXPECTED' => {
		    # if purge_valid is set to 1 a valid certificate of this
		    # type found on the smartcard will be purged
		    purge_valid => 0,
		    # if purge_valid is set to 1 an invalid (e. g. expired) 
		    # certificate found on the smartcard will be purged
		    purge_invalid => 0,
		},
		# certificates unknown to our PKI
		'FOREIGN' => {
		    # if purge_valid is set to 1 a valid certificate of this
		    # type found on the smartcard will be purged
		    purge_valid => 1,
		    # if purge_valid is set to 1 an invalid (e. g. expired) 
		    # certificate found on the smartcard will be purged
		    purge_invalid => 0,
		}
	    },
	},
    };
    
    #our $ldap_settings;

    # 2010-10-28 Martin Bartosch: TODO FIXME XXX
    # This is a really ugly hack to avoid slurping in configuration from
    # our XML. Needs badly to be rewritten prior to pushing to upstream.
    # XXXXXXXXXXXXX
    do '/etc/openxpki/policy.pm' || die "Could not open ldap parameters file.";
    ##! 16: 'policy: ' . Dumper $policy

    ###########################################################################
    ##! 16: 'indexing policy'
    my $ref;
  TYPE:
    foreach my $type (keys %{$policy->{certs}->{type}}) {
	my $index = 0;
	##! 16: "cert type: $type"

	foreach my $allowed_profile (@{$policy->{certs}->{type}->{$type}->{allowed_profiles}}) {
	    $ref->{profile}->{$allowed_profile}->{type} = $type;
	    if (! $index++) {
		# first profile is preferred
		$ref->{profile}->{$allowed_profile}->{preferred} = 1;
	    }
	    
	    $ref->{type}->{$type}->{allowed_profile}->{$allowed_profile} = 1;
	}

	foreach my $item (qw( min_count max_count max_age )) {
	    $ref->{type}->{$type}->{limits}->{$item} 
	    = $policy->{certs}->{type}->{$type}->{limits}->{$item};
	}

	foreach my $item (qw( allow_renewal key_escrow publish purge_invalid purge_valid )) {
	    $ref->{type}->{$type}->{policy}->{$item} 
	    = $policy->{certs}->{type}->{$type}->{$item};
	}

	foreach my $usage (@{$policy->{certs}->{type}->{$type}->{usage}}) {
	    ##! 16: 'usage: ' . $usage
	    $ref->{usage}->{$usage}->{type} = $type;
	    $ref->{type}->{$type}->{usage}->{$usage} = 1;
	}

	##! 16: "certificate type: $type; policy: " . Dumper $policy->{certs}->{type}->{$type}
    }

    $policy->{xref} = $ref;

    ##! 16: 'complete policy: ' . Dumper $policy

    return $policy;
}


sub __check_db_hash_against_policy {
    my $self = shift;
    my $db_hash = shift;

    # fetch policy data
    ##! 16: 'fetching policy'
    my $policy = $self->_get_policy();

    my $thisrealm = CTX('session')->get_pki_realm();
    
    my $profile = $db_hash->{PROFILE};
    ##! 16: 'profile: ' . $profile
    
    ####################################################################
    # determine certificate type
    # $type can be one of the following:
    # 'FOREIGN':
    #   certificate is unknown to this PKI instance (not in database)
    # 'UNEXPECTED':
    #   certificate is known to this PKI instance but was not expected
    #   on the token (unexpected profile)
    # '...':
    #   certificate is expected on the card
    my $type = 'FOREIGN';
    if (defined $profile) {
	# cert is know to our PKI
	$type = $policy->{xref}->{profile}->{$profile}->{type};
	my $is_preferred = $policy->{xref}->{profile}->{$profile}->{preferred} || 0;

	$db_hash->{CERTIFICATE_TYPE} = $type;
	
	if (! defined $type) {
	    $type = 'UNEXPECTED';
	    # but it is not expected on the token (incorrect profile)
	    $db_hash->{SMARTCARD_USAGE} = { 
		'NONE' => 1 
	    };
	} else {
	    # we expect this cert type on the token, and hence export
	    # the intended usage
	    foreach my $usage (keys %{ $policy->{xref}->{type}->{$type}->{usage}}) {
		# export usage to caller
		$db_hash->{SMARTCARD_USAGE}->{$usage} = 1;
	    }

	    # check if private key is available in the database for
	    # escrowed certificates
	    $db_hash->{PRIVATE_KEY_AVAILABLE} = 0;

	    if ($policy->{certs}->{type}->{$type}->{escrow_key}) {
		my $identifier = $db_hash->{IDENTIFIER};
		##! 16: 'checking if private key is available for cert identifier ' . $identifier
		
		my $private_key_found = CTX('dbi_backend')->first (
		    TABLE => 'DATAPOOL',
		    DYNAMIC => {
			PKI_REALM    => $thisrealm,
			NAMESPACE    => 'certificate.privatekey',
			DATAPOOL_KEY => $identifier,
		    },
		    );
		
		if (defined $private_key_found) {
		    $db_hash->{PRIVATE_KEY_AVAILABLE} = 1;
		} else {
		    ##! 16: 'private key not in datapool for cert identifier ' . $identifier
		    CTX('log')->log(
			MESSAGE  => "Private key not found for escrow certificate [$identifier], dequeueing",
			PRIORITY => 'info',
			FACILITY => 'system',
			);
		}
	    }
	    
	    $db_hash->{PREFERRED_PROFILE} = $is_preferred;
	}
	
	# todo: check against database if this particular cert
	# is expected
    } else {
	$db_hash->{SMARTCARD_USAGE} = { 
	    'UNKNOWN' => 1,
	};
    }
    
    
    ####################################################################
    # determine certificate properties
    my %validity_properties = (
	not_revoked => 1,
	);
    
    # cert is not scheduled for revocation (or has unknown revocation 
    # status)
    if (defined $db_hash->{STATUS} && ($db_hash->{STATUS} ne 'ISSUED')) {
	$validity_properties{not_revoked} = 0;
    }
    
    # validity computations
    # cert is within validity period
    my $now = DateTime->now();
    my $notbefore = DateTime->from_epoch( epoch => $db_hash->{NOTBEFORE} );
    my $notafter = DateTime->from_epoch( epoch => $db_hash->{NOTAFTER} );
    
    
    $validity_properties{within_validity_period} =
	0 + ((DateTime->compare($notbefore, $now) < 0) &&
	     (DateTime->compare($now, $notafter) < 0));
    
    foreach my $entry(qw( allow_renewal force_renewal )) {
	$validity_properties{$entry} = 0;
	if (defined $policy->{certs}->{type}->{$type}->{$entry}) {
	    my $renewal_date = OpenXPKI::DateTime::get_validity(
		{
		    REFERENCEDATE => $notafter,
		    VALIDITY => $policy->{certs}->{type}->{$type}->{$entry},
		    VALIDITYFORMAT => 'relativedate',
		});
	    
	    if (DateTime->compare($now, $renewal_date) > 0) {
		$validity_properties{$entry} = 1;
	    }
	}
    }
    
    # propagate information to result structure
    $db_hash->{VALIDITY_PROPERTIES} = \%validity_properties;
    
    
    # visual status may be 'green' (valid), 'amber' (nearing expiration)
    # or 'red' (expired or revoked)
    
    if ($policy->{certs}->{type}->{$type}->{purge_invalid}) {
	# only set red status on certs that shall be purged 
	# after expiration
	
	if ((! $validity_properties{within_validity_period})
	    || (! $validity_properties{not_revoked})) {
	    # expired or revoked
	    $db_hash->{VISUAL_STATUS} ||= 'red';
	    $db_hash->{PROCESS_FLAGS}->{PURGE} = 1;
	}
    }
    
    if ($policy->{certs}->{type}->{$type}->{purge_valid}) {
	# policy do not want us to keep this certificate
	
	$db_hash->{VISUAL_STATUS} ||= 'red';
	$db_hash->{PROCESS_FLAGS}->{PURGE} = 1;
    }

    if ($validity_properties{force_renewal}) {
	$db_hash->{VISUAL_STATUS} ||= 'red';
    }
    if ($validity_properties{allow_renewal}) {
	$db_hash->{VISUAL_STATUS} ||= 'amber';
    }
    # TODO: check if profile should be propagated to preferred profile
    
    # if nothing has been set, assume it's ok
    $db_hash->{VISUAL_STATUS} ||= 'green';
    
    return $db_hash;
}



# takes a single certificate and parses it. cert may specified literally
# or as a cert identifier (in which case it must exist in the database)
# args:
# DATA: raw data of cert
# CERTFORMAT: 
#   BASE64 (raw base64 will be converted correctly to DER)
#   DER
#   PEM
#   IDENTIFIER (DATA is interpreted as cert identifier to look up in db)
# DONTPARSE: 1 (optional)
#   Only acceptable for cert format 'IDENTIFIER'. If set, the certificate
#   fetched from the database will not be parsed, but only the cert information
#   from the database (CSR and CERTIFICATE table entries) will be propagated.
# 
# returns data structure with parsed certificate information, augmented
# with results from policy settings (if applicable)
sub sc_analyze_certificate {
    my $self = shift;
    my $arg_ref = shift;

    my $certformat = $arg_ref->{CERTFORMAT};
    my $dontparse  = $arg_ref->{DONTPARSE};
    my $data       = $arg_ref->{DATA};
    my $cfg_id  = $arg_ref->{CONFIG_ID};
    ##! 16: 'cfg_id: ' . $cfg_id

    my $thisrealm   = CTX('session')->get_pki_realm();

    my $default_token;

    if (defined $cfg_id) {
	$default_token = CTX('pki_realm_by_cfg')->{$cfg_id}->{$thisrealm}->{crypto}->{default};
    } else {
	$default_token = CTX('pki_realm')->{$thisrealm}->{crypto}->{default};
    }

    ##! 16: 'default token obtained'
    if ($dontparse && ($certformat ne 'IDENTIFIER')) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_PARSING_REQUIRED_FOR_CERTFORMAT',
	    params  => {
		CERTFORMAT => $certformat,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }
    
    if ($certformat eq 'BASE64') {
	$data = MIME::Base64::decode_base64($data);
	$certformat = 'DER';
    }
    if (! defined $data) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_INVALID_DATA',
	    params  => {
		CERT => $data,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }
    if ($certformat eq 'DER') {
	##! 16: 'converting DER to PEM'
	$data = $default_token->command(
	    {
		COMMAND => 'convert_cert',
		IN      => $certformat,
		OUT     => 'PEM',
		DATA    => $data,
	    });
	$certformat = 'PEM';
    }

    my $x509;
    my $db_hash = {};
    my $identifier;
    if ($certformat eq 'PEM') {
	##! 16: 'PEM Data: ' . $data
	$x509 = OpenXPKI::Crypto::X509->new(
	    DATA => $data,
	    TOKEN => $default_token,
	    );
	$db_hash = { 
	    $x509->to_db_hash(),
	};
	$identifier = $db_hash->{IDENTIFIER};
    } elsif ($certformat eq 'IDENTIFIER') {
	$identifier = $data;
    } else {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_INVALID_CERTFORMAT',
	    params  => {
		CERTFORMAT => $arg_ref->{CERTFORMAT},
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }
    
    # search certificate in database
    ##! 16: 'searching certificate with identifier: ' . $identifier
    
    my $db_results = CTX('dbi_backend')->first(
	TABLE => [
	    'CERTIFICATE',
	    'CSR',
	],
	COLUMNS => [
	    'CSR.PROFILE',
	    'CERTIFICATE.ISSUER_IDENTIFIER',
	    'CERTIFICATE.ROLE',
	    'CERTIFICATE.STATUS',
	    'CERTIFICATE.PKI_REALM',
	    'CERTIFICATE.DATA',
	    'CERTIFICATE.NOTBEFORE',
	    'CERTIFICATE.NOTAFTER',
	],
	DYNAMIC => {
	    'CERTIFICATE.IDENTIFIER' => $identifier,
	},
	JOIN => [
	    [
	     'CSR_SERIAL',
	     'CSR_SERIAL',
	    ],
	],
	);

    # entry was found in the database
    if (defined $db_results) {
	if (! (defined $x509 || $dontparse)) {
	    # cert raw data was not supplied as an argument (but found in
	    # the database)
	    ##! 16: 'parsing certificate'
	    $x509 = OpenXPKI::Crypto::X509->new(
		DATA => $db_results->{'CERTIFICATE.DATA'},
		TOKEN => $default_token,
		);

	    $db_hash = { 
		$x509->to_db_hash(),
	    };
	}
	
	# merge database query results with parsed cert
	##! 16: 'merging certificate information from database'
	$db_hash = {
	    %{$db_hash},
	    IDENTIFIER        => $identifier,
	    PKI_REALM         => $db_results->{'CERTIFICATE.PKI_REALM'},
	    ISSUER_IDENTIFIER => $db_results->{'CERTIFICATE.ISSUER_IDENTIFIER'},
	    ROLE              => $db_results->{'CERTIFICATE.ROLE'},
	    STATUS            => $db_results->{'CERTIFICATE.STATUS'},
	    PROFILE           => $db_results->{'CSR.PROFILE'},
	    NOTBEFORE         => $db_results->{'CERTIFICATE.NOTBEFORE'},
	    NOTAFTER          => $db_results->{'CERTIFICATE.NOTAFTER'},
	};

	##! 16: 'cert data: ' . Dumper $db_hash

	# cert was found in database, so we can check it against the policy
	# determine certificate profile and possibly certificate usage
	$db_hash = $self->__check_db_hash_against_policy($db_hash);
    }

    # remove raw cert data from output
    delete $db_hash->{DATA};
    
    # include validity information in iso format
    foreach my $entry (qw( NOTBEFORE NOTAFTER )) {
	my $date_obj = DateTime->from_epoch( epoch => $db_hash->{$entry});
	$db_hash->{$entry . '_ISO'} = 
	    OpenXPKI::DateTime::convert_date(
		{
		    DATE => $date_obj,
		    OUTFORMAT => 'printable',
		});
    }

    if (defined $x509) {
	my $modulus = $x509->get_parsed('BODY', 'MODULUS');
	##! 16: 'modulus: ' . $modulus

	# compute PKCS#11 plugin compatible key id
	# remove leading null bytes for hash computation
	$modulus =~ s/^(?:00)+//g;
	$db_hash->{MODULUS_HASH} = sha1_hex(pack('H*', $modulus));
	##! 16: 'pkcs11 plugin keyid hash: ' . $db_hash->{MODULUS_HASH}
    }
    
    # Windows UPN
    # FIXME
    $db_hash->{SUBJECT_UPN} = 'FIXME';

    ##! 16: 'parsed certificate: ' . Dumper $db_hash
    return $db_hash;
}

1;
__END__

=head1 Name

OpenXPKI::Server::API::Smartcard

=head1 Description

This API handles Smartcard specific calls.

=head1 Functions

=head2 sc_parse_certificates

This function parses the specified certificates and returns the parsed 
results in the return list.

=head3 Named function parameters

=over 8

=item * CERTS (mandatory)

This parameter is a list of certificates as read from the card.

=item * CERTFORMAT (mandatory)

Supported formats for the CERTS parameter are DER|PEM|BASE64|IDENTIFIER.
BASE64 will accept degraded formats (i. e. data without whitespace or padding).
If IDENTIFIER is selected, the function will retrieve the specified
certificate from the database
and analyze it.

=back

=head3 Synopsis

The function iterates through all certificates passed to the function
and parses them.

If the certificate is found in the database it is also
checked against the desired policy.

Determine the certificate type:

=over 8

=item * If the certificate is not known to the system (not found in 
the database), the type is set to "FOREIGN"

=item * If the certificate was found in the database, but
according to the policy should not be found on the
card the type will be set to "UNEXPECTED"

=item * If the certificate was expected on the certificate
the type is set to the symbolic name from the policy.

=back

=head3 Function results

The function will return an array reference containing the detailed 
information about the passed certificates. 
A single entry of the list has the following structure (not all entries 
may be set):

=over 8

=item * CERTIFICATE_SERIAL

=item * IDENTIFIER

=item * PKI_REALM

=item * SUBJECT

=item * ISSUER_DN

=item * ISSUER_IDENTIFIER

=item * EMAIL

=item * PUBKEY

=item * SUBJECT_KEY_IDENTIFIER

=item * AUTHORITY_KEY_IDENTIFIER

=item * NOTBEFORE

Seconds since Epoch

=item * NOTBEFORE_ISO

NotBefore date in ISO format

=item * NOTAFTER

Seconds since Epoch

=item * NOTAFTER_ISO

NotAfter date in ISO format

=item * ROLE

=item * STATUS

=item * PROFILE

=item * CERTIFICATE_TYPE

If the type is "FOREIGN" the system does not know this certificate.
If it is "UNEXPECTED", the system knows the certificate but has decided 
it should normally not be present on the card. 
Everything else: the certificate was expected on the card, and the type 
contains the symbolic purpose name of the certificate as set in the policy.

=item * PRIVATE_KEY_AVAILABLE

This value is set to 1 if the corresponding private key is available 
in the database.

=item * PREFERRED_PROFILE

This is set to 1 if the profile of this certificate is the most recent 
of the accepted profiles for the intended purpose.

=item * SMARTCARD_USAGE

This value is a hash ref, with the keys being the intended purposes. 
If the key NONE is set, the certificate does not fit any purpose 
according to the configured policy.

=back

=head2 sc_analyze_smartcard

This API function can be called by an OpenXPKI client in order to 
analyze the state of a given Smartcard.

=head3 Named function parameters

=over 8

=item * SMARTCARDID (mandatory)

This parameter shall be set to the Smartcard chip serial number 
as read from the card. The API function will query this serial number
from the associated directory or repository and determine the 
designated owner of the card.

The parameter format is defined in the Smartcard Interfaces document.

=item * USERID (optional)

If available, the user id of the currently logged in user should be 
supplied by the caller. This may be different from the actual 
Smartcard holder.

=item * CERTS (optional)

see sc_parse_certificates

=item * CERTFORMAT (mandatory if CERTS is given)

see sc_parse_certificates

=item * WORKFLOW_TYPES (optional)

This parameter is a list of workflow type names to be queried. If 
specified, the analyze function will search for existing workflows of 
the specified types that are owned by the holder of the Smartcard 
of SMARTCARDID.

This is merely a convenience function that simply wraps the 
search_workflow_instances API function.

=head3 Function results

The function will return a complex data structure containing the 
results of the Smartcard analysis.

These results are directly influenced by

=over 8

=item * internal status of the PKI database (e. g. existing certificates
for the user)

=item * external resources (such as LDAP directory contents)

=item * the passed parameters and

=item * the configured policy

=back

The results of the function can be directly used for decisions on how 
the actual personalization should happen. 

=head4 Return structure:

=over 8


=item * OVERALL_STATUS (scalar)

This is the global status of the Smartcard which can be directly 
displayed by the frontend.

Possible values: 'green' (default), 'amber', 'red'


=item *            - SMARTCARD (hashref)

The referenced structure contains the details of the Smartcard:

=over 8

=item * serialnumber (scalar)

Canonical serial number of the Smartcard

=item * status (scalar)

Smartcard status

=item * assigned_to (scalar)

Designated holder of the Smartcard

=item * keyalg (scalar)

Asymmetric algorith supported (preferred) by this Smartcard

=item * keysize (scalar)

Key size supported (preferred) by this Smartcard

=item * default_puk (scalar)

Default PUK for this Smartcard (may be undefined)

=back

=item * CERT_TYPE (hashref)

symbolic type name (hash, taken from policy configuration, one entry
for each configured type)

=over 8

=item * usable_cert_exists (scalar, interpreted as boolean)

A usable certificate for this purpose exists in the database.

=item * token_contains_expected_cert (scalar, interpreted as boolean)

The Smartcard contains the expected certificate for this purpose.

=item * escrow_private_key (scalar, interpreted as boolean)

If the Smartcard is missing the certificate, the workflow will 
install the necessary certificate on the Smartcard. 

If this value is false, the private key shall be generated on the
Smartcard by the frontend.

If the value is true, the Workflow will generate a private key and store it internally.

=back

=item * CERT_TYPES (array)

Lists all certificate types configured for this Smartcard. This is 
identical to the keys of CERT_TYPE in the return structure.

=item * WORKFLOWS (hashref)

Returned data is identical to the result of the 
search_workflow_instances() API function.

=item * PROCESS_FLAGS (hash of scalars, interpreted as booleans)

These flags can be used for decisions in the personalization workflow.

=over 8

=item * allow_personalization

User is allowed to start a personalization workflow (complex decision 
based on smartcard status, puk availability etc)

=item * will_need_pin

Smartcard PIN is required for following operations (either the user's 
pin or an autogenerated random pin)

=item * will_need_random_pin

If false the user may select his own pin, otherwise the pin will be 
selected by the server

=item * allow_user_pin

Allow user to enter existing pin (otherwise autogenerate random 
pin -> pin unblock needed after completion)

=item * need_wf_approval

Policy setting: if set 0/false no approval is required for user 
cert issuance

=item * purge_token_before_unblock

Policy setting: if true the token must be completely purged before 
an unblock operation may happen

=item * have_cert_to_delete

Smartcard cleanup is necessary (at least one certificate must be 
deleted from the card)

=item * have_cert_to_unpublish

Directory cleanup is necessary (at least one certificate must be 
deleted from the directory)

=item * puk_is_writable

Smartcard puk can be modified

=item * puk_found_in_datapool

Smartcard puk is available in datapool

=back



Parsed certificates:



VISUAL_STATUS:
'green': certificate is OK
'amber': certificate is still valid but may be renewed (will expire soon)
'red': certificate is expired or revoked

Expired certificates with 
