## OpenXPKI::Server::API::Smartcard.pm 
##
## Written 2010 by Martin Bartosch for the OpenXPKI project
## Redesign using Connector by Oliver Welter 2012
## Copyright (C) 2005-2010 by The OpenXPKI Project

package OpenXPKI::Server::API::Smartcard;

use strict;
use warnings;
use utf8;
use English;

use OpenXPKI::Debug;
use OpenXPKI::Exception;
use OpenXPKI::Server::Context qw( CTX );
use OpenXPKI::Crypto::X509;
use DateTime;
use OpenXPKI::DateTime;
use OpenXPKI::i18n;

use Net::LDAP;
use Class::Std;
use MIME::Base64;
use Data::Dumper;
use Digest::SHA1 qw( sha1_hex );

sub START {
    # somebody tried to instantiate us, but we are just an
    # utility class with static methods
    OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SUBCLASSES_CAN_NOT_BE_INSTANTIATED',
    );
}

# named parameters:
# CERTFORMAT => DER|PEM|IDENTIFIER|BASE64 (allows degraded formats, 
#   e. g. without newlines)
# CERTS => arrayref, entries contain raw cert data
sub sc_parse_certificates {
    ##! 1: 'init'
    my $self = shift;
    my $arg_ref = shift;

    my $cfg_id = $arg_ref->{CONFIG_ID};
    
    if ($arg_ref->{CERTFORMAT} !~ m{ \A (?:DER|PEM|BASE64|IDENTIFIER) \z }xms) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_PARSE_CERTIFICATES_INVALID_CERT_FORMAT',
	    params  => {
		CERTFORMAT => $arg_ref->{CERTFORMAT},
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    my $certs = $arg_ref->{CERTS};

    my @result;

    foreach my $entry (@{$certs}) {
	my $data = $self->sc_analyze_certificate(
	    {
		CONFIG_ID  => $cfg_id,
		DATA       => $entry,
		CERTFORMAT => $arg_ref->{CERTFORMAT},
	    });

	##! 16: 'parsed certificate: ' . Dumper $data

	push @result, $data;
    }
    ##! 1: 'parsed certs: ' . Dumper \@result;
    return \@result;
}


# named parameters:
# SCMARTCARDID => scalar, token id read from token. format: TYPE_SERIAL
# 
# CERTFORMAT => see sc_parse_certificates
# CERTS => see sc_parse_certificates
# USERID => scalar, authenticated user (optional, if present may be 
#           different from sc holder)
# WORKFLOW_TYPES => arrayref, existing workflow types to search (optional)
sub sc_analyze_smartcard {
    my $self = shift;
    my $arg_ref = shift;

    my $tokenid  = $arg_ref->{SMARTCARDID};
    my $chipid  = $arg_ref->{SMARTCHIPID};    
    my $userid   = $arg_ref->{USERID};
    my $wf_types = $arg_ref->{WORKFLOW_TYPES};
    my $cfg_id   = $arg_ref->{CONFIG_ID};
    my $login_ids  = $arg_ref->{LOGIN_IDS};
    
    ##! 16: 'cfg_id: ' . $cfg_id

    ##! 16: 'sc_analyze_smartcard() wf_types = $wf_types (' . Dumper($wf_types) . ')'

    if (defined $wf_types && (ref $wf_types ne 'ARRAY')) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_INVALID_WORKFLOW_TYPES_UNEXPECTED_DATA_TYPE',
	    params  => {
		DATA_TYPE => ref $wf_types,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }

    my $thisrealm = CTX('session')->get_pki_realm();

    ##! 16: ' Load policy map '
    # get policy settings from configuration
    my $policy = $self->_get_policy();

    my $result = {
        WF_TYPES => $wf_types,
	OVERALL_STATUS => 'green',
	SMARTCARD => {
	    serialnumber => '',
	    status => 'unknown',
	    assigned_to => {},
	    user_data_source => '',
	    keyalg => 'RSA',
	    keysize => 2048,
	    default_puk => undef,
	    keyid => undef
	},
	CERT_TYPE => {
#	    'nonescrow' => {
#		usable_cert_exists => 0,
#		token_contains_expected_cert => 0,
#	    },
	  # 2010-09-17 MB FIXME: the following section disables escrow 
	  # certificate generation, cleanup and remove!
	    'escrow' => {
		usable_cert_exists => 1,
		token_contains_expected_cert => 1,
	    },
	    # certificates known to our PKI system but not expected on card
	    # (should be purged)
	    #'OTHER' => {
	    #
	    #},
	    # 3rd party certificates, keep on card
	    #'FOREIGN' => {
	    #    
	    #},
	},
	WORKFLOWS => undef,
	PROCESS_FLAGS => {
	    # user is allowed to start a personalization workflow (complex
	    # decision based on smartcard status, puk availability etc)
	    allow_personalization => 1,
	    # smartcard PIN is required for following operations (either
	    # the user's pin or an autogenerated random pin)
	    will_need_pin => 0,
	    # policy setting: if set to 0 the user may select his own pin,
	    # otherwise the pin will be selected by the server
	    will_need_random_pin => 1,
	    # allow user to enter existing pin (otherwise 
	    # autogenerate random pin -> pin unblock needed after 
	    # completion)
	    allow_user_pin => 0,
	    # policy setting: if set 0 no approval is required for user cert
	    # issuance
	    need_wf_approval => 0,
	    # policy setting: if true the token must be completely purged
	    # before an unblock operation may happen
	    purge_token_before_unblock => 0,
	    # smartcard cleanup is necessary
	    have_cert_to_delete => 0,
	    # directory cleanup is necessary
	    have_cert_to_unpublish => 0,
	    # smartcard puk can be modified
	    puk_is_writable => 1,
	    # smartcard puk is available in datapool
	    puk_found_in_datapool => 0,
	},
    };

    my $config = CTX('config');
    
    my $holder_employee_id;
    
    #########################################################################
    # Based on the id of the card we need to obtain the card status and the
    # assigned employee. 
    
    # Info about smartcard status is fetched from connector at
    # smartcard.cardstatus
    # attributes: serialnumber, status, keyid (optional)
    
    my $res  = $config->walkQueryPoints('smartcard.cardstatus', $tokenid, 'get_hash');    
        
    ##! 32: ' SC Info: Token Id '.$tokenid.' - Cardinfo ' . Dumper( $res->{VALUE} );
    # There should never be a match when tokenid ist not an exact match
    # So we should be able to omit the sanity check some lines below..   
          
    if (!$res->{VALUE} || !$res->{VALUE}->{status}) {
        
        OpenXPKI::Exception->throw(
            message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_TOKEN_NOT_FOUND',
            params  => {
                TOKENID => $tokenid,                
            },
            log => {
                logger => CTX('log'),
                priority => 'error',
                facility => [ 'system', ],
            },
        );                
    }
    
    my $scinfo = $res->{VALUE};
    
    ##! 64: ' Sanity check token status word ' . $scinfo->{status}  
	# sanity check, only allow defined smartcard status
	if ($scinfo->{status} !~ m{ \A (?:initial|activated|deactivated) \z }xms) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_INVALID_SMARTCARD_STATUS',
		params  => {
		    TOKENID => $tokenid,
		    STATUS  => $scinfo->{status},
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);
	} # Status Check

    ##! 64: ' Sanity check tokenid ' . $scinfo->{serialnumber}
        	
    # sanity check: token id must be identical to the one passed
    # in the api call
    if ($tokenid ne $scinfo->{serialnumber}) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_TOKENID_MISMATCH',
        params  => {
            TOKENID_FROM_API => $tokenid,
            TOKENID_FROM_CONNECTOR => $scinfo->{serialnumber},
        },
        log => {
            logger => CTX('log'),
            priority => 'error',
            facility => [ 'system', ],
        },
        );

    }
	
    # found and valid status - assign to result     
    foreach my $key qw(status serialnumber keyid) {
        $result->{SMARTCARD}->{$key} = $scinfo->{$key};       
    }	

    ########################################################################
    # Find the employee id based on the smartcard id

    $res  = $config->walkQueryPoints('smartcard.card2user', $tokenid, 'get');    
	     
	$holder_employee_id = $res->{VALUE};
	
	if ( !$holder_employee_id ) {
	    OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_NO_EMPLOYEEID_FOR_TOKEN',
        params  => {
            TOKENID => $tokenid,                
        },
        log => {
            logger => CTX('log'),
            priority => 'error',
            facility => [ 'system', ],
        },
        );    
	}

    ##! 16: 'Employeeid is ' . $holder_employee_id  

	
	#### Step 3 #############################################################

    # New in Phase 2: Record or validate SMARTCARDID/SMARTCHIPID mapping.
    # Check datapool if the specified SMARTCHIPID has been recorded for
    # the given SMARTCARDID.
    # If not, record the new mapping in the datapool. (Suggested namespace:
    # 'smartcard.smartchipid', key: SMARTCARDID, value:
    # SMARTCHIPID. Currently this is not done at all.)
    # If yes, validate that it matches the input of this call.
    # If this validation fails, this is a security violation (somebody
    # probably modified the SMARTCARDID).

    if ($chipid) {

    # Check for existing entry
    my $msg = CTX('api')->get_data_pool_entry( { KEY => $chipid , NAMESPACE => 'smartcard.smartchipid' } );

    my $retval = $msg->{VALUE};
    
    # Not found - record it
    if (!$retval) {
        ##! 16: "Record card/chip relation Chip: $chipid - Token: $tokenid " 
        CTX('api')->set_data_pool_entry( { 
            KEY => $chipid , 
            NAMESPACE => 'smartcard.smartchipid',
            VALUE => $tokenid,
        } );        
    } elsif( $retval ne $tokenid ) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARDID_MISSMATCHES_RECORDED_VALUE',
        params  => {
            SMARTCHIPID => $chipid,
            SMARTCARDID => $tokenid,
            RECORDED_SMARTCARDID => $retval, 
        },
        log => {
            logger => CTX('log'),
            priority => 'error',
            facility => [ 'system', ],
        },
        );
        
    }
    }
        
    ##### Step 4 ############################################################
    
    # New in Phase 2: Determine current user by employee ID.
    
    # From Step 1 we know the employee ID. An employee ID maps to a person.
    # In order to obtain additional information about the Smartcard holder,
    # query configured data source (for now and very likely only LDAP
    # directory, check with tester if artificial data is required, in this 
    # case a lookup needs to be implemented with a local configuration 
    # file preceding the LDAP query).
    # 
    # Values read from the directory:
    # 
    # * givenName
    # * middleInitials
    # * surname
    # * mail
    # * list of Windows login IDs (loginids)
    # 
    # The "wanted" Login Ids are no longer passed to this function but 
    # queried from the frontend (and validated) in ApplyCSRPolicy step 

    ##! 32: ' Find employee id '

    # Connector - Multi-Valued type
    my $employeeinfo = $config->walkQueryPoints( 'smartcard.employee', $holder_employee_id, { call => 'get_hash', deep => 1 } );    

    if (!$employeeinfo) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_SEARCH_PERSON_FAILED',
		params  => {
		    EMPLOYEEID => $holder_employee_id
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
	    );
	}
	    
    # loginids is expected to be an array ref but might be a scalar in result
    if (ref ($employeeinfo->{VALUE}->{loginids}) eq '') {
        my $loginid = $employeeinfo->{VALUE}->{loginids};
        $employeeinfo->{VALUE}->{loginids} = [ $loginid ];
    } 	    
	    
    # This should be ok as the hash should be correctly assembled by the connector
    $result->{SMARTCARD}->{assigned_to} = $employeeinfo->{VALUE};

    # Record the name of the resolver where we got the user info from
    $result->{SMARTCARD}->{user_data_source} = $employeeinfo->{SOURCE};
    	    
    ##! 16: 'smartcard holder details from connector: ' . Dumper $employeeinfo
	    

    # FIXME 
    # $smartcard_holder_login_id is no longer unique, for the workflows we use the employeeid 
    # the certificates directly use the mail attribute 

    $result->{SMARTCARD}->{assigned_to}->{workflow_creator} = $holder_employee_id;

    my $max_smartcards_per_user = $policy->get( ['cards.max_smartcards_per_user'] );

    if (defined $max_smartcards_per_user) {

        # TODO - check if user has too many cards        
        my $smartcards_this_user = 1;
        
        ##! 16: 'checking for max number of smartcards per user'
		if ($smartcards_this_user > $max_smartcards_per_user ) {
		    OpenXPKI::Exception->throw(
                message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_TOO_MANY_SMARTCARDS',
                params  => {
				    USER => $holder_employee_id,
				    SMARTCARD_COUNT => $smartcards_this_user,
				    #SMARTCARDS => join(';', map { $_->get_value('seealso') } @smartcard_entries),
				},
				log => {
				    logger => CTX('log'),
				    priority => 'error',
				    facility => [ 'system', ],
				},
				);
		}	
    } # end $max_smartcards_per_user


    #### Step 5 #############################################################
    # check membership of logged in user (if specified) in configured groups
    # Disabled for the moment!
    if (0 && defined $userid) {
    
    	# Map the userid to a lookup key
    	my $lookupid = $config->get('smartcard.groupinfo.usertokey');

    	##! 16: "userid $userid maps to $lookupid"

	   foreach my $group_alias ($config->get_keys('smartcard.groupinfo.groups')) {
	    
	       my $process_flag = 'is_' . $group_alias;
	    
	       $result->{PROCESS_FLAGS}->{$process_flag} = 0;

	       if (defined $lookupid) {
        	    ##! 16: 'checking membership for group ' . $group_alias
                ## FIXME - Needs testing         		
                if ($config->get(['smartcard.groupinfo.checkgroup', $group_alias, $lookupid ])) {        		
                    $result->{PROCESS_FLAGS}->{$process_flag} = 1;
                }
            }
	   }
    }
    
    
    #### Step 6 #############################################################
    # Search for active workflows for this user (only if WORKFLOW_TYPES was
    # passed). This operation is a convenience shortcut for the frontend 
    # which may wish to continue a stalled personalization workflow.

    # search workflows
    if (defined $wf_types) {
	# get workflow information (existing workflows for user)
	foreach my $wf_type (@{$wf_types}) {
	    $result->{WORKFLOWS}->{$wf_type} =
		CTX('api')->search_workflow_instances(
		    {
			TYPE => $wf_type,
			CONTEXT => [
			    {
				KEY => 'creator',
				VALUE => $holder_employee_id,
			    },
			    ],
		    });
	}
    }

    #### Step 7 ##############################################################
    # Determine PUK status and possibly other properties of the Smartcard.
    # Depending on the PUK status set result values. The consumer of this 
    # function call may need the information if the PUK is known and 
    # available or if the PUK can be modified.
    # Here we only get the basic capabilities of the card and the
    # information on if we know the PUK. We don't fetch the actual PUK here,
    # this is done when it is actually needed in the workflow.
    # * boolean flag: PUK in Datapool (custom puk, that was set on the card 
    #   earlier)
    # * boolean flag: PUK is writable (some Smartcards do not allow 
    #   changing the PUK).
    # * boolean flag: purge token before unblock. if set to true by the API
    #   function, this indicates that the Smartcard must be completely
    #   erased (for security reasons) before an unblock operation can
    #   happen. True for RSA tokens (because we do not necessarily have a 
    #   token - user assignment during unblock), false for most other cards.
    # * integer: supported keysize of the card
    
    my $puk_found = CTX('api')->get_data_pool_entry( {
        PKI_REALM => $thisrealm,
        NAMESPACE => 'smartcard.puk',
        KEY => $tokenid,         
    } );
    
    if (defined $puk_found) {
	   $result->{PROCESS_FLAGS}->{puk_found_in_datapool} = 1;
    }

    ###########################################################################
    # Load PUK properties based on smartcard type from Config
    # We assume that the tokenid contains the cardtype as a prefix, seperated 
    # by an underscore (<type>_<token nummer>)
    # Todo - implement the getHash idea on the base connector
    
    $tokenid =~ m{ \A (?:(\w+\d)_) }xms;
    my $token_family = $1;
    my $token_config;
    
    if (!$token_family || !($token_config = $config->get_hash(['smartcard.cardinfo.properties',$token_family]))) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_UNSUPPORTED_SMARTCARD_TYPE',
        params  => {
        TOKEN_ID => $tokenid,
        },
        log => {
        logger => CTX('log'),
        priority => 'error',
        facility => [ 'system', ],
        },
        );
    }    
    
	$result->{PROCESS_FLAGS}->{puk_is_writable} = $token_config->{'puk_is_writable'} || 0;
	$result->{PROCESS_FLAGS}->{purge_token_before_unblock} = $token_config->{'purge_token_before_unblock'} || 0;
	$result->{SMARTCARD}->{keysize} = $token_config->{'keysize'};
	
	#$result->{SMARTCARD}->{default_puk} = undef;	
	#$config->get(['smartcard.cardinfo.properties.defaultpuk'])
        
    #### Step 8 ###############################################################    
    # This step prepares an output structure that can be used by the
    # frontend or the workflow to operate on the details of certificates
    # already on the card.
    # The input paramters to the sc_analyze_smartcard function contains a
    # list of Base64 encoded certificates as read from the Smartcard.
    # Iterate through this list and parse all certificates, generating a
    # hash array containing details on every single certificate.
    # Populate a return structure that contains the parsed version of all
    # certificates on the Smartcard.
    # analyze contents of the card
    
    # Helper to split the certificates based on the form type
    $result->{PARSED_CERTS} = $self->sc_parse_certificates($arg_ref);

    ###########################################################################
    # sort and index the exisiting certificates
    
    my $user_certs = {
	by_identifyer => {},
	by_type => {},
	by_profile => {},
	xref => {
	    expected_certs => {
		all => {
		    list => [],
		    # preallocate identifer hash (needed later)
		    identifier => {},
		}
	    },
	},
    };
    
    foreach my $type ($policy->get_keys('certs.type')) {
	next if ($type =~ m{ \A (?:UNEXPECTED|FOREIGN) \z }xms);
	$user_certs->{by_type}->{$type} = [];
    }
    
    ##! 32: ' Loading Profiles from xref.profile '    
    my @profiles = $policy->get_keys('xref.profile');
    foreach my $profile ( @profiles) {
        $user_certs->{by_profile}->{$profile} = [];
    }

    ##! 32: ' Loaded ' . Dumper ( $user_certs->{by_profile} )

    #### Step 9 #############################################################
    # Get existing certificates for the holder of the current Smartcard.
    #
    # The employee ID maps to a user who may have had one or even
    # more different names and hence person entries before. We need to find
    # all existing certificates for the user, regardless of previous name.
    # We maintain a list of a users certificates in the datapool
    # namespace: smartcard.user.certificate
    # key: employee id
    # value: serialized array of certificate identifiers
    
     my $certificates = CTX('api')->get_data_pool_entry( {
        PKI_REALM => $thisrealm,
        NAMESPACE => 'smartcard.user.certificate',
        KEY => $holder_employee_id,         
    } );
    
    if ($certificates) {
    
    my $ser = OpenXPKI::Serialization::Simple->new();
    my @certificate_identifiers = $ser->deserialize($certificates->{VALUE});

    my $db_results = CTX('dbi_backend')->select(
	TABLE => [
	    'CERTIFICATE',
	    'CSR',
	],
	COLUMNS => [
	    'CSR.PROFILE',
	    'CERTIFICATE.SUBJECT',
	    'CERTIFICATE.IDENTIFIER',
	    'CERTIFICATE.ROLE',
	    'CERTIFICATE.STATUS',
	    'CERTIFICATE.DATA',
	    'CERTIFICATE.NOTBEFORE',
	    'CERTIFICATE.NOTAFTER',
	],
	DYNAMIC => {
	    'CSR.PROFILE' => \@profiles,
	    'CERTIFICATE.PKI_REALM' => $thisrealm,
	    'CERTIFICATE.IDENTIFIER' => \@certificate_identifiers,
	},
	JOIN => [
	    [
	     'CSR_SERIAL',
	     'CSR_SERIAL',
	    ],
	],
	);
	    
	# Loop thru results 
    foreach my $entry (@{$db_results}) {
		my $db_hash = {};
		
		# merge database query results with parsed cert
		##! 16: 'merging certificate information from database'
		my $identifier = $entry->{'CERTIFICATE.IDENTIFIER'};
		$db_hash = {
		    %{$db_hash},
		    IDENTIFIER        => $identifier,
		    PROFILE           => $entry->{'CSR.PROFILE'},
		    ROLE              => $entry->{'CERTIFICATE.ROLE'},
		    SUBECT            => $entry->{'CERTIFICATE.SUBJECT'},
		    STATUS            => $entry->{'CERTIFICATE.STATUS'},
		    NOTBEFORE         => $entry->{'CERTIFICATE.NOTBEFORE'},
		    NOTAFTER          => $entry->{'CERTIFICATE.NOTAFTER'},
		};

		$db_hash = $self->__check_db_hash_against_policy($db_hash);
		
		##! 16: 'certificate details: ' . Dumper $db_hash

		# save full certificate details
		$user_certs->{by_identifier}->{$identifier} = $db_hash;
		
		# resolve type from profile using xref, NB: requires that a profile may not be used in two types		
		my $type = $policy->get(['xref.profile', $db_hash->{PROFILE}, 'type']); 
		# xrefs
		push @{$user_certs->{by_type}->{$type}}, 
		    $user_certs->{by_identifier}->{$identifier};
		push @{$user_certs->{by_profile}->{$db_hash->{PROFILE}}}, 
		    $user_certs->{by_identifier}->{$identifier};
    } # db loop
    } # if certificates
    ##! 16: 'certificates already existing for user: ' . Dumper $user_certs

    ###########################################################################
    # process policy requirements for all user certificates

    foreach my $type ($policy->get_keys('certs.type')) {
	next if ($type =~ m{ \A (?:UNEXPECTED|FOREIGN) \z }xms);

	$result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 0;
	$result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;
	$result->{CERT_TYPE}->{$type}->{preferred_cert_exists} = 0;
	
	my @expected_certs;
	my $min_certs = $policy->get(['certs.type', $type, 'limits.min_count']);
	my $max_certs = $policy->get(['certs.type', $type, 'limits.max_count']);

	my $cutoff_date;
	my $max_age = $policy->get(['certs.type', $type, 'limits.max_age']);
	if (defined $max_age) {
	    $cutoff_date = OpenXPKI::DateTime::get_validity(
		{
		    REFERENCEDATE => DateTime->now(),
		    VALIDITY => $max_age,
		    VALIDITYFORMAT => 'relativedate',
		});
	}

	# sort certificates by notbefore date (descending)
	@{$user_certs->{by_type}->{$type}} 
	    = sort { $b->{NOTBEFORE} <=> $a->{NOTBEFORE} } 
	        @{$user_certs->{by_type}->{$type}};
	
	
      CERT_TO_RETAIN:
	foreach my $entry (@{$user_certs->{by_type}->{$type}}) {
	    if (defined $max_certs && 
		(scalar @expected_certs >= $max_certs)) {
		##! 16: 'max number of certificates to retain reached: ' . $max_certs
		last CERT_TO_RETAIN;
	    }
	    
	    if (defined $cutoff_date) {
		##! 16: 'checking for maximum age: ' . Dumper $cutoff_date
		my $notbefore = DateTime->from_epoch( epoch => $entry->{NOTBEFORE} );
		if (DateTime->compare($notbefore, $cutoff_date) > 0) {
		    push @expected_certs, $entry->{IDENTIFIER};
		}
	    } else {
		push @expected_certs, $entry->{IDENTIFIER};
	    }
	}
	
	# propagate flag if at least one certificate exists
	if (scalar @expected_certs > 0) {
	    $result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 1;
	    ##! 16: 'at least one certificate exists for type: ' . $type

	    # if the latest certficate has been revoked or is valid
	    # for less than the configured threshold, we propagate
	    # that we have no usable certificate
	    my $cert_id = $expected_certs[0];
	    my $cert = $user_certs->{by_identifier}->{$cert_id};
	    
	    if ($cert->{VALIDITY_PROPERTIES}->{allow_renewal}
		|| $cert->{VALIDITY_PROPERTIES}->{force_renewal}
		|| (!$cert->{VALIDITY_PROPERTIES}->{within_validity_period})
		|| (!$cert->{VALIDITY_PROPERTIES}->{not_revoked})) {
		##! 16: 'certificate does not qualify because of its validity properties: ' . Dumper $cert->{VALIDITY_PROPERTIES}
		$result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 0;
	    }

	    # if the latest certificate's private key is not in the database
	    # this does not qualify as a 'usable' certificate (only for
	    # certs which should be escrowed)
	     
	    if ($policy->get(['certs.type', $type, 'escrow_key'])
		&& ! $cert->{PRIVATE_KEY_AVAILABLE}) {
		##! 16: 'certificate does not qualify because it is supposed to be an escrowed cert and no private key is available'
		$result->{CERT_TYPE}->{$type}->{usable_cert_exists} = 0;
	    }
	}
    
	
	# index by type
	$user_certs->{xref}->{expected_certs}->{type}->{$type}->{list} = \@expected_certs;
	%{$user_certs->{xref}->{expected_certs}->{type}->{$type}->{identifier}} = 
	    map { $_ => 1 } @expected_certs;

	# complete list
	push @{$user_certs->{xref}->{expected_certs}->{all}->{list}},
	    @expected_certs;

	# by identifier
	map { 
	    $user_certs->{xref}->{expected_certs}->{all}->{identifier}->{$_} = 1;
	} @expected_certs;
	
    }
    ##! 16: 'certificates sorted, by type: ' . Dumper $user_certs->{by_type}
    
    ##! 16: 'xref: ' . Dumper $user_certs->{xref}
    ###########################################################################
    # analyze certificates on card
    $result->{TASKS}->{SMARTCARD}->{INSTALL} = [];
    $result->{TASKS}->{SMARTCARD}->{PURGE} = [];
    $result->{TASKS}->{DIRECTORY}->{UNPUBLISH} = [];

    my $index = 0;
    
    my %to_restore = %{$user_certs->{xref}->{expected_certs}->{all}->{identifier}};
    ##! 16: 'to_restore: ' . Dumper \%to_restore

    # create a checklist of certs which are expected on the token
    my %missing_certs_on_token_by_type =
	%{$user_certs->{xref}->{expected_certs}->{type}};
    ##! 16: 'missing certs: ' . Dumper \%missing_certs_on_token_by_type

    my %certs_on_token_by_type;
    my %preferred_cert_available_by_type;

    foreach my $entry (@{$result->{PARSED_CERTS}}) {
	my $identifier = $entry->{IDENTIFIER};
	my $cert = $user_certs->{by_identifier}->{$identifier};
	my $cert_type = $cert->{CERTIFICATE_TYPE} || 'FOREIGN';
	my $cert_visual_status = $cert->{VISUAL_STATUS};
	my $is_preferred_profile = $cert->{PREFERRED_PROFILE};

	##! 16: 'identifier: ' . $identifier
	##! 16: 'type: ' . $cert_type
	##! 16: 'is preferred: ' . $is_preferred_profile
	$preferred_cert_available_by_type{$cert_type} ||= $is_preferred_profile;

	push @{$certs_on_token_by_type{$cert_type}}, $identifier;
	
	# escalate overall visual status
	if (defined $cert_visual_status) {
	    # do not consider certficates which are escrowed (used for
	    # encyption)	           
	    if (! $policy->get(['certs.type', $cert_type, 'escrow_key'])) {
		$result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		    $result->{OVERALL_STATUS},
		    $cert_visual_status,
		    );
	    }
	}

	# remove cert from the list of expected certs
	delete $missing_certs_on_token_by_type{$cert_type}->{identifier}->{$identifier};
	
	# certificate possibly already exists on card, we don't have 
	# to recover it
	delete $to_restore{$identifier};

	# purge certificates already scheduled for deletion
	if ($entry->{PROCESS_FLAGS}->{PURGE}) {
	    $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	    $result->{PROCESS_FLAGS}->{have_cert_to_delete} = 1;
	    
	    push @{ $result->{TASKS}->{SMARTCARD}->{PURGE} },
	    {
		INDEX      => $index,
		IDENTIFIER => $entry->{IDENTIFIER},
		SUBJECT    => $entry->{SUBJECT},
		MODULUS_HASH => $entry->{MODULUS_HASH},
	    };
	}
    }
    ##! 16: 'missing certs: ' . Dumper \%missing_certs_on_token_by_type
    ##! 16: 'certs on token by type: ' . Dumper \%certs_on_token_by_type
    ##! 16: 'preferred profile found by type: ' . Dumper \%preferred_cert_available_by_type

    # identify certs to restore
    ##! 16: 'to_restore: ' . Dumper \%to_restore
  CERT_TO_RESTORE:
    foreach my $identifier (@{$user_certs->{xref}->{expected_certs}->{all}->{list}}) {
	##! 16: 'identifier: ' . $identifier
	my $cert = $user_certs->{by_identifier}->{$identifier};
	my $cert_type = $cert->{CERTIFICATE_TYPE};
	
	# only propagate escrow certificates for recovery
	if (defined $to_restore{$identifier}) {
	    ##! 16: 'flagged for recovery'
            
	    if ($policy->get(['certs.type', $cert_type, 'escrow_key'])) {
		##! 16: 'is escrow cert, queue for recovery'
		if ($policy->get(['certs.type', $cert_type, 'ignore_certificates_with_missing_private_key'])) {
		    ##! 16: 'checking if private key is available for cert identifier ' . $identifier
		    
		    if (! $cert->{PRIVATE_KEY_AVAILABLE}) {
			##! 16: 'private key not in datapool for cert identifier ' . $identifier
			next CERT_TO_RESTORE;
		    }
		}
		push @{$result->{TASKS}->{SMARTCARD}->{INSTALL}}, $identifier;
		$result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	    }
	}
    }

    # check for certificates missing on token
  CERT_TYPE:
    foreach my $type (keys (%missing_certs_on_token_by_type)) {
	next CERT_TYPE if ($type =~ m{ \A (?:FOREIGN|UNEXPECTED) }xms);	
	my $min_count = $policy->get(['certs.type', $type, 'limits.min_count'])|| 0;
	##! 16: 'check if expected certificates are present for type ' . $type
	$result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 1;
	
	my $cert_count = 0;
	if (exists $certs_on_token_by_type{$type}) {
	    $cert_count = scalar @{$certs_on_token_by_type{$type}};
	}

	# check for minimum number of certs
	if ($cert_count < $min_count) {
	    ##! 16: "too few certs on token for type $type (found $cert_count, expected $min_count)"
	    $result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;
	    
	    $result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		$result->{OVERALL_STATUS},
		'red',
		);
	    $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	}

	if (scalar keys %{$missing_certs_on_token_by_type{$type}->{identifier}} > 0) {
	    ##! 16: 'certs missing on token: ' . Dumper $missing_certs_on_token_by_type{$type}->{identifier}
	    $result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;

	    $result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		$result->{OVERALL_STATUS},
		'red',
		);
	    $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
	}
    }

    # check if preferred profile is available on token and possibly tell
    # workflow to upgrade certificate
    foreach my $type (keys %preferred_cert_available_by_type) {
	next if ($type eq 'FOREIGN');

	if ($policy->get(['certs.type', $type, 'promote_to_preferred_profile'])) {
	    if ( $preferred_cert_available_by_type{$type}) {
            # As the preferred certifiate exists, the check if it is on the
            # card is done above - so no need to take care of it here.
	        $result->{CERT_TYPE}->{$type}->{preferred_cert_exists} = 1;
	    } else {
		    $result->{CERT_TYPE}->{$type}->{token_contains_expected_cert} = 0;
			
		$result->{OVERALL_STATUS} = $self->_aggregate_visual_status(
		    $result->{OVERALL_STATUS},
		    'red',
		    );
		$result->{PROCESS_FLAGS}->{will_need_pin} = 1;
				
    	}
    }
    }
       
    # an overall status that is not green indicates that we probably need the
    # pin
    if ($result->{OVERALL_STATUS} ne 'green') {
	$result->{PROCESS_FLAGS}->{will_need_pin} = 1;
    }

    ##! 16: 'analysis result: ' . Dumper $result
    return $result;
}

# compute new overall visual status based on input
# returns the "maximum" of the passed input values
# input: array of string, allowed values must be one of 'green', 'amber', 'red'
# output: "maximum" of the passed values
sub _aggregate_visual_status {
    my $self = shift;
    my @args = @_;
    my %escalation_level_of = (
	'green' => 0,
	'amber' => 1,
	'red' => 2,
	);
    my %color_of = map { $escalation_level_of{$_} => $_ } 
        keys %escalation_level_of;

    my $overall_level = 0;
    foreach my $status (@args) {
	if (! exists $escalation_level_of{$status}) {
	    OpenXPKI::Exception->throw(
		message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_AGGREGATE_VISUAL_STATUS_INVALID_STATUS_CODE',
		params  => {
		    VISUAL_STATUS => $status,
		},
		log => {
		    logger => CTX('log'),
		    priority => 'error',
		    facility => [ 'system', ],
		},
		);
	}
	if ($escalation_level_of{$status} > $overall_level) {
	    $overall_level = $escalation_level_of{$status};
	}
    }
    
    return $color_of{$overall_level};
}

sub _get_policy {
    my $self = shift;
    my $arg_ref = shift;

    # Policy is now served from conenctor 
    my $config = CTX('config');
    my $policy = $config->get_wrapper( 'smartcard.policy' );

    # This is currently only working inside one execution thread due to forking                
    # We need to run the index only once
    if ($policy->get('xref.cached')) {
        ##! 8: 'policy already indexed'
        return $policy;
    }
    
    

    ###########################################################################
    ##! 8: 'indexing policy'
    my $ref;

    foreach my $type ( $policy->get_keys( [ 'certs.type'] ) ) {
    
        my $isFirst = 1;       
        foreach my $allowed_profile ($policy->get_list([  'certs.type', $type, 'allowed_profiles' ])) {    
            $policy->set(['xref.profile', $allowed_profile, 'type'], $type );        
            if ($isFirst) {
                # first profile is preferred
                $policy->set(['xref.profile', $allowed_profile, 'preferred'], 1 );
                $isFirst = 0;            
            }                
            $policy->set(['xref.type', $type, 'allowed_profile', $allowed_profile ], 1 );
        }
            
        foreach my $item (qw( min_count max_count max_age )) {
            $policy->set([ 'xref.type', $type, 'limits', $item ], $policy->get([ 'certs.type', $type, 'limits', $item ]));
        }
            
        foreach my $item (qw( allow_renewal escrow_key publish purge_invalid purge_valid )) {
            $policy->set([ 'xref.type', $type,'policy',$item], $policy->get([  'certs.type', $type, $item ]));         
        }
    
        foreach my $usage ($policy->get_list([  'certs.type', $type, 'usage' ])) {    
            #$policy->set([ 'xref.usage', $usage, 'type' ], $type ); # Seems not to be in use
            $policy->set([ 'xref.type' , $type, 'usage', $usage ], 1 );        
        }             
    }
   
    $policy->set('xref.cached', 1);
    
    ##! 64: Dumper ( $policy->get_hash('xref.type') )
            
    return $policy;
}


sub __check_db_hash_against_policy {
    my $self = shift;
    my $db_hash = shift;

    # fetch policy data
    ##! 16: 'fetching policy'
    my $policy = $self->_get_policy();

    my $thisrealm = CTX('session')->get_pki_realm();
    
    my $profile = $db_hash->{PROFILE};
    ##! 16: 'profile: ' . $profile
    
    ####################################################################
    # determine certificate type
    # $type can be one of the following:
    # 'FOREIGN':
    #   certificate is unknown to this PKI instance (not in database)
    # 'UNEXPECTED':
    #   certificate is known to this PKI instance but was not expected
    #   on the token (unexpected profile)
    # '...':
    #   certificate is expected on the card
    my $type = 'FOREIGN';
    if (defined $profile) {
	# cert is know to our PKI
	$type = $policy->get(['xref.profile', $profile, 'type']);
	my $is_preferred = $policy->get(['xref.profile', $profile, 'preferred']) || 0;

	$db_hash->{CERTIFICATE_TYPE} = $type;
	
	if (! defined $type) {
	    $type = 'UNEXPECTED';
	    # but it is not expected on the token (incorrect profile)
	    $db_hash->{SMARTCARD_USAGE} = { 
		'NONE' => 1 
	    };
	} else {
	    # we expect this cert type on the token, and hence export
	    # the intended usage

	    # 20120504 Martin Bartosch, TODO/REFACTOR: bit mask?
	    foreach my $usage ($policy->get_keys(['xref.type', $type, 'usage'])) {
    		# export usage to caller
	       	$db_hash->{SMARTCARD_USAGE}->{$usage} = 1;
	    }

	    # check if private key is available in the database for
	    # escrowed certificates
	    $db_hash->{PRIVATE_KEY_AVAILABLE} = 0;
        
	    if ($policy->get(['certs.type', $type, 'escrow_key'])) {
		my $identifier = $db_hash->{IDENTIFIER};
		##! 16: 'checking if private key is available for cert identifier ' . $identifier
		
		my $private_key_found = CTX('dbi_backend')->first (
		    TABLE => 'DATAPOOL',
		    DYNAMIC => {
			PKI_REALM    => $thisrealm,
			NAMESPACE    => 'certificate.privatekey',
			DATAPOOL_KEY => $identifier,
		    },
		    );
		
		if (defined $private_key_found) {
		    $db_hash->{PRIVATE_KEY_AVAILABLE} = 1;
		} else {
		    ##! 16: 'private key not in datapool for cert identifier ' . $identifier
		    CTX('log')->log(
			MESSAGE  => "Private key not found for escrow certificate [$identifier], dequeueing",
			PRIORITY => 'info',
			FACILITY => 'system',
			);
		}
	    }
	    
	    $db_hash->{PREFERRED_PROFILE} = $is_preferred;
	}
	
	# todo: check against database if this particular cert
	# is expected
    } else {
	$db_hash->{SMARTCARD_USAGE} = { 
	    'UNKNOWN' => 1,
	};
    }
    
    
    ####################################################################
    # determine certificate properties
    my %validity_properties = (
	not_revoked => 1,
	);
    
    # cert is not scheduled for revocation (or has unknown revocation 
    # status)
    if (defined $db_hash->{STATUS} && ($db_hash->{STATUS} ne 'ISSUED')) {
	$validity_properties{not_revoked} = 0;
    }
    
    # validity computations
    # cert is within validity period
    my $now = DateTime->now();
    my $notbefore = DateTime->from_epoch( epoch => $db_hash->{NOTBEFORE} );
    my $notafter = DateTime->from_epoch( epoch => $db_hash->{NOTAFTER} );
    
    
    $validity_properties{within_validity_period} =
	0 + ((DateTime->compare($notbefore, $now) < 0) &&
	     (DateTime->compare($now, $notafter) < 0));
    
    foreach my $entry(qw( allow_renewal force_renewal )) {
	$validity_properties{$entry} = 0;
	my $validity = $policy->get(['certs.type', $type, $entry]);
	if (defined $validity) {
	    my $renewal_date = OpenXPKI::DateTime::get_validity(
		{
		    REFERENCEDATE => $notafter,
		    VALIDITY => $validity,
		    VALIDITYFORMAT => 'relativedate',
		});
	    
	    if (DateTime->compare($now, $renewal_date) > 0) {
		$validity_properties{$entry} = 1;
	    }
	}
    }
    
    # propagate information to result structure
    $db_hash->{VALIDITY_PROPERTIES} = \%validity_properties;
    
    
    # visual status may be 'green' (valid), 'amber' (nearing expiration)
    # or 'red' (expired or revoked)
    
    
    if ($policy->get(['certs.type', $type, 'purge_invalid'])) {
	# only set red status on certs that shall be purged 
	# after expiration
	
	if ((! $validity_properties{within_validity_period})
	    || (! $validity_properties{not_revoked})) {
	    # expired or revoked
	    $db_hash->{VISUAL_STATUS} ||= 'red';
	    $db_hash->{PROCESS_FLAGS}->{PURGE} = 1;
	}
    }
    
    if ($policy->get(['certs.type', $type, 'purge_valid'])) {
	# policy do not want us to keep this certificate
	
	$db_hash->{VISUAL_STATUS} ||= 'red';
	$db_hash->{PROCESS_FLAGS}->{PURGE} = 1;
    }

    if ($validity_properties{force_renewal}) {
	$db_hash->{VISUAL_STATUS} ||= 'red';
    }
    if ($validity_properties{allow_renewal}) {
	$db_hash->{VISUAL_STATUS} ||= 'amber';
    }
    # TODO: check if profile should be propagated to preferred profile
    
    # if nothing has been set, assume it's ok
    $db_hash->{VISUAL_STATUS} ||= 'green';
    
    return $db_hash;
}



# takes a single certificate and parses it. cert may specified literally
# or as a cert identifier (in which case it must exist in the database)
# args:
# DATA: raw data of cert
# CERTFORMAT: 
#   BASE64 (raw base64 will be converted correctly to DER)
#   DER
#   PEM
#   IDENTIFIER (DATA is interpreted as cert identifier to look up in db)
# DONTPARSE: 1 (optional)
#   Only acceptable for cert format 'IDENTIFIER'. If set, the certificate
#   fetched from the database will not be parsed, but only the cert information
#   from the database (CSR and CERTIFICATE table entries) will be propagated.
# 
# returns data structure with parsed certificate information, augmented
# with results from policy settings (if applicable)
sub sc_analyze_certificate {
    my $self = shift;
    my $arg_ref = shift;

    my $certformat = $arg_ref->{CERTFORMAT};
    my $dontparse  = $arg_ref->{DONTPARSE};
    my $data       = $arg_ref->{DATA};
    my $cfg_id  = $arg_ref->{CONFIG_ID};
    ##! 16: 'cfg_id: ' . $cfg_id

    my $thisrealm   = CTX('session')->get_pki_realm();

    my $default_token;

    if (defined $cfg_id) {
	$default_token = CTX('pki_realm_by_cfg')->{$cfg_id}->{$thisrealm}->{crypto}->{default};
    } else {
	$default_token = CTX('pki_realm')->{$thisrealm}->{crypto}->{default};
    }

    ##! 16: 'default token obtained'
    if ($dontparse && ($certformat ne 'IDENTIFIER')) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_PARSING_REQUIRED_FOR_CERTFORMAT',
	    params  => {
		CERTFORMAT => $certformat,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }
    
    if ($certformat eq 'BASE64') {
	$data = MIME::Base64::decode_base64($data);
	$certformat = 'DER';
    }
    if (! defined $data) {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_INVALID_DATA',
	    params  => {
		CERT => $data,
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }
    if ($certformat eq 'DER') {
	##! 16: 'converting DER to PEM'
	$data = $default_token->command(
	    {
		COMMAND => 'convert_cert',
		IN      => $certformat,
		OUT     => 'PEM',
		DATA    => $data,
	    });
	$certformat = 'PEM';
    }

    my $x509;
    my $db_hash = {};
    my $identifier;
    if ($certformat eq 'PEM') {
	##! 16: 'PEM Data: ' . $data
	$x509 = OpenXPKI::Crypto::X509->new(
	    DATA => $data,
	    TOKEN => $default_token,
	    );
	$db_hash = { 
	    $x509->to_db_hash(),
	};
	$identifier = $db_hash->{IDENTIFIER};
    } elsif ($certformat eq 'IDENTIFIER') {
	$identifier = $data;
    } else {
	OpenXPKI::Exception->throw(
	    message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_INVALID_CERTFORMAT',
	    params  => {
		CERTFORMAT => $arg_ref->{CERTFORMAT},
	    },
	    log => {
		logger => CTX('log'),
		priority => 'error',
		facility => [ 'system', ],
	    },
	    );
    }
    
    # search certificate in database
    ##! 16: 'searching certificate with identifier: ' . $identifier
    
    my $db_results = CTX('dbi_backend')->first(
	TABLE => [
	    'CERTIFICATE',
	    'CSR',
	],
	COLUMNS => [
	    'CSR.PROFILE',
	    'CERTIFICATE.ISSUER_IDENTIFIER',
	    'CERTIFICATE.ROLE',
	    'CERTIFICATE.STATUS',
	    'CERTIFICATE.PKI_REALM',
	    'CERTIFICATE.DATA',
	    'CERTIFICATE.NOTBEFORE',
	    'CERTIFICATE.NOTAFTER',
	],
	DYNAMIC => {
	    'CERTIFICATE.IDENTIFIER' => $identifier,
	},
	JOIN => [
	    [
	     'CSR_SERIAL',
	     'CSR_SERIAL',
	    ],
	],
	);

    # entry was found in the database
    if (defined $db_results) {
	if (! (defined $x509 || $dontparse)) {
	    # cert raw data was not supplied as an argument (but found in
	    # the database)
	    ##! 16: 'parsing certificate'
	    $x509 = OpenXPKI::Crypto::X509->new(
		DATA => $db_results->{'CERTIFICATE.DATA'},
		TOKEN => $default_token,
		);

	    $db_hash = { 
		$x509->to_db_hash(),
	    };
	}
	
	# merge database query results with parsed cert
	##! 16: 'merging certificate information from database'
	$db_hash = {
	    %{$db_hash},
	    IDENTIFIER        => $identifier,
	    PKI_REALM         => $db_results->{'CERTIFICATE.PKI_REALM'},
	    ISSUER_IDENTIFIER => $db_results->{'CERTIFICATE.ISSUER_IDENTIFIER'},
	    ROLE              => $db_results->{'CERTIFICATE.ROLE'},
	    STATUS            => $db_results->{'CERTIFICATE.STATUS'},
	    PROFILE           => $db_results->{'CSR.PROFILE'},
	    NOTBEFORE         => $db_results->{'CERTIFICATE.NOTBEFORE'},
	    NOTAFTER          => $db_results->{'CERTIFICATE.NOTAFTER'},
	};

	##! 16: 'cert data: ' . Dumper $db_hash

	# cert was found in database, so we can check it against the policy
	# determine certificate profile and possibly certificate usage
	$db_hash = $self->__check_db_hash_against_policy($db_hash);
    }

    # remove raw cert data from output
    delete $db_hash->{DATA};
    
    # include validity information in iso format
    foreach my $entry (qw( NOTBEFORE NOTAFTER )) {
	my $date_obj = DateTime->from_epoch( epoch => $db_hash->{$entry});
	$db_hash->{$entry . '_ISO'} = 
	    OpenXPKI::DateTime::convert_date(
		{
		    DATE => $date_obj,
		    OUTFORMAT => 'printable',
		});
    }

    if (defined $x509) {
	my $modulus = $x509->get_parsed('BODY', 'MODULUS');
	##! 16: 'modulus: ' . $modulus

	# compute PKCS#11 plugin compatible key id
	# remove leading null bytes for hash computation
	$modulus =~ s/^(?:00)+//g;
	$db_hash->{MODULUS_HASH} = sha1_hex(pack('H*', $modulus));
	##! 16: 'pkcs11 plugin keyid hash: ' . $db_hash->{MODULUS_HASH}
    }
    
    # Windows UPN
    # FIXME
    $db_hash->{SUBJECT_UPN} = 'FIXME';

    ##! 16: 'parsed certificate: ' . Dumper $db_hash
    return $db_hash;
}

1;
__END__

=head1 Name

OpenXPKI::Server::API::Smartcard

=head1 Description

This API handles Smartcard specific calls.

=head1 Functions

=head2 sc_parse_certificates

This function parses the specified certificates and returns the parsed 
results in the return list.

=head3 Named function parameters

=over 8

=item * CERTS (mandatory)

This parameter is a list of certificates as read from the card.

=item * CERTFORMAT (mandatory)

Supported formats for the CERTS parameter are DER|PEM|BASE64|IDENTIFIER.
BASE64 will accept degraded formats (i. e. data without whitespace or padding).
If IDENTIFIER is selected, the function will retrieve the specified
certificate from the database
and analyze it.

=back

=head3 Synopsis

The function iterates through all certificates passed to the function
and parses them.

If the certificate is found in the database it is also
checked against the desired policy.

Determine the certificate type:

=over 8

=item * If the certificate is not known to the system (not found in 
the database), the type is set to "FOREIGN"

=item * If the certificate was found in the database, but
according to the policy should not be found on the
card the type will be set to "UNEXPECTED"

=item * If the certificate was expected on the certificate
the type is set to the symbolic name from the policy.

=back

=head3 Function results

The function will return an array reference containing the detailed 
information about the passed certificates. 
A single entry of the list has the following structure (not all entries 
may be set):

=over 8

=item * CERTIFICATE_SERIAL

=item * IDENTIFIER

=item * PKI_REALM

=item * SUBJECT

=item * ISSUER_DN

=item * ISSUER_IDENTIFIER

=item * EMAIL

=item * PUBKEY

=item * SUBJECT_KEY_IDENTIFIER

=item * AUTHORITY_KEY_IDENTIFIER

=item * NOTBEFORE

Seconds since Epoch

=item * NOTBEFORE_ISO

NotBefore date in ISO format

=item * NOTAFTER

Seconds since Epoch

=item * NOTAFTER_ISO

NotAfter date in ISO format

=item * ROLE

=item * STATUS

=item * PROFILE

=item * CERTIFICATE_TYPE

If the type is "FOREIGN" the system does not know this certificate.
If it is "UNEXPECTED", the system knows the certificate but has decided 
it should normally not be present on the card. 
Everything else: the certificate was expected on the card, and the type 
contains the symbolic purpose name of the certificate as set in the policy.

=item * PRIVATE_KEY_AVAILABLE

This value is set to 1 if the corresponding private key is available 
in the database.

=item * PREFERRED_PROFILE

This is set to 1 if the profile of this certificate is the most recent 
of the accepted profiles for the intended purpose.

=item * SMARTCARD_USAGE

This value is a hash ref, with the keys being the intended purposes. 
If the key NONE is set, the certificate does not fit any purpose 
according to the configured policy.

=back

=head2 sc_analyze_smartcard

This API function can be called by an OpenXPKI client in order to 
analyze the state of a given Smartcard.

=head3 Named function parameters

=over 8

=item * SMARTCARDID (mandatory)

This parameter shall be set to the Smartcard chip serial number 
as read from the card. The API function will query this serial number
from the associated directory or repository and determine the 
designated owner of the card.

The parameter format is defined in the Smartcard Interfaces document.

=item * USERID (optional)

If available, the user id of the currently logged in user should be 
supplied by the caller. This may be different from the actual 
Smartcard holder.

=item * CERTS (optional)

see sc_parse_certificates

=item * CERTFORMAT (mandatory if CERTS is given)

see sc_parse_certificates

=item * WORKFLOW_TYPES (optional)

This parameter is a list of workflow type names to be queried. If 
specified, the analyze function will search for existing workflows of 
the specified types that are owned by the holder of the Smartcard 
of SMARTCARDID.

This is merely a convenience function that simply wraps the 
search_workflow_instances API function.

=head3 Function results

The function will return a complex data structure containing the 
results of the Smartcard analysis.

These results are directly influenced by

=over 8

=item * internal status of the PKI database (e. g. existing certificates
for the user)

=item * external resources (such as LDAP directory contents)

=item * the passed parameters and

=item * the configured policy

=back

The results of the function can be directly used for decisions on how 
the actual personalization should happen. 

=head4 Return structure:

=over 8


=item * OVERALL_STATUS (scalar)

This is the global status of the Smartcard which can be directly 
displayed by the frontend.

Possible values: 'green' (default), 'amber', 'red'


=item *            - SMARTCARD (hashref)

The referenced structure contains the details of the Smartcard:

=over 8

=item * serialnumber (scalar)

Canonical serial number of the Smartcard

=item * status (scalar)

Smartcard status

=item * assigned_to (scalar)

Designated holder of the Smartcard

=item * keyalg (scalar)

Asymmetric algorith supported (preferred) by this Smartcard

=item * keysize (scalar)

Key size supported (preferred) by this Smartcard

=item * default_puk (scalar)

Default PUK for this Smartcard (may be undefined)

=back

=item * CERT_TYPE (hashref)

symbolic type name (hash, taken from policy configuration, one entry
for each configured type)

=over 8

=item * usable_cert_exists (scalar, interpreted as boolean)

A usable certificate for this purpose exists in the database.

=item * token_contains_expected_cert (scalar, interpreted as boolean)

The Smartcard contains the expected certificate for this purpose.

=item * escrow_private_key (scalar, interpreted as boolean)

If the Smartcard is missing the certificate, the workflow will 
install the necessary certificate on the Smartcard. 

If this value is false, the private key shall be generated on the
Smartcard by the frontend.

If the value is true, the Workflow will generate a private key and store it internally.

=back

=item * CERT_TYPES (array)

Lists all certificate types configured for this Smartcard. This is 
identical to the keys of CERT_TYPE in the return structure.

=item * WORKFLOWS (hashref)

Returned data is identical to the result of the 
search_workflow_instances() API function.

=item * PROCESS_FLAGS (hash of scalars, interpreted as booleans)

These flags can be used for decisions in the personalization workflow.

=over 8

=item * allow_personalization

User is allowed to start a personalization workflow (complex decision 
based on smartcard status, puk availability etc)

=item * will_need_pin

Smartcard PIN is required for following operations (either the user's 
pin or an autogenerated random pin)

=item * will_need_random_pin

If false the user may select his own pin, otherwise the pin will be 
selected by the server

=item * allow_user_pin

Allow user to enter existing pin (otherwise autogenerate random 
pin -> pin unblock needed after completion)

=item * need_wf_approval

Policy setting: if set 0/false no approval is required for user 
cert issuance

=item * purge_token_before_unblock

Policy setting: if true the token must be completely purged before 
an unblock operation may happen

=item * have_cert_to_delete

Smartcard cleanup is necessary (at least one certificate must be 
deleted from the card)

=item * have_cert_to_unpublish

Directory cleanup is necessary (at least one certificate must be 
deleted from the directory)

=item * puk_is_writable

Smartcard puk can be modified

=item * puk_found_in_datapool

Smartcard puk is available in datapool

=back



Parsed certificates:



VISUAL_STATUS:
'green': certificate is OK
'amber': certificate is still valid but may be renewed (will expire soon)
'red': certificate is expired or revoked

Expired certificates with 
